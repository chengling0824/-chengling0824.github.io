<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chenry&#39;s sky</title>
  
  
  <link href="https://chengling0824.github.io/atom.xml" rel="self"/>
  
  <link href="https://chengling0824.github.io/"/>
  <updated>2021-05-12T07:44:26.120Z</updated>
  <id>https://chengling0824.github.io/</id>
  
  <author>
    <name>程羚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>玩转SpringBoot</title>
    <link href="https://chengling0824.github.io/2021/05/11/%E7%8E%A9%E8%BD%ACSpringBoot/"/>
    <id>https://chengling0824.github.io/2021/05/11/%E7%8E%A9%E8%BD%ACSpringBoot/</id>
    <published>2021-05-11T03:25:35.000Z</published>
    <updated>2021-05-12T07:44:26.120Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="IDEA中创建和启动SpringBoot应用"><a href="#IDEA中创建和启动SpringBoot应用" class="headerlink" title="IDEA中创建和启动SpringBoot应用"></a>IDEA中创建和启动SpringBoot应用</h1><blockquote><p>声明：本文中使用的是IDEA社区版</p></blockquote><h2 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h2><p>1、在file》setting》plugins中找到Spring Assistant，安装后重启idea</p><img src="https://i.loli.net/2021/05/11/gBLX8KjVZwpDJl2.png" alt="image-20210511143250561" style="zoom: 50%;" /><p>2、创建新的spring boot项目，步骤如下，然后点击next：（这里的spring assistant就相当于其它教程里的Spring Initializr）</p><img src="https://i.loli.net/2021/05/11/aMO7DEmQrWcSxV4.png" alt="image-20210511143704161" style="zoom: 50%;" /><p>设置好自己的包名和项目名，然后点击next；</p><img src="https://i.loli.net/2021/05/11/ftYqLHFkjZQyGIX.png" alt="image-20210511143953159" style="zoom: 67%;" /><img src="https://i.loli.net/2021/05/11/iWUhx7RaAwJHtM2.png" alt="image-20210511144106192" style="zoom:67%;" /><p>要选择的依赖：</p><img src="%E7%8E%A9%E8%BD%ACSpringBoot.assets/image-20210511171722171.png" alt="image-20210511171722171" style="zoom: 80%;" /><img src="https://i.loli.net/2021/05/11/onKSQfyCDzGaih4.png" alt="image-20210511144152174" style="zoom:67%;" /><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><img src="https://i.loli.net/2021/05/11/dSKxIPaN8BgAhJM.png" alt="image-20210511144517482" style="zoom:67%;" /><h2 id="配置项目和数据链接"><a href="#配置项目和数据链接" class="headerlink" title="配置项目和数据链接"></a>配置项目和数据链接</h2><p>打开 application.properties 文件，写入配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#1.项目启动的端口</span><br><span class="line">server.port=<span class="number">8090</span></span><br><span class="line"></span><br><span class="line">#2.数据库连接参数</span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/db_book</span></span><br><span class="line">spring.datasource.driver-<span class="class"><span class="keyword">class</span>-<span class="title">name</span></span>=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="number">123</span></span><br></pre></td></tr></table></figure><blockquote><p>db_book是先前创建好的数据库，测试前需先设计好数据库，数据表（MySQL）</p></blockquote><p>打开启动类（SpingbootApplication）测试，显示以下信息则配置数据链接成功：</p><p><img src="https://i.loli.net/2021/05/12/5cW87vTnEDfCwt1.png" alt="image-20210512093327659"></p><h2 id="创建SpringBoot分层结构"><a href="#创建SpringBoot分层结构" class="headerlink" title="创建SpringBoot分层结构"></a>创建SpringBoot分层结构</h2><p>（1）持久层（dao/mapper）：包括XxxMapper.java(数据库访问接口类)，XxxMapper.xml(数据库链接实现)；（这个命名，有人喜欢用Dao命名，有人喜欢用Mapper，看个人习惯了吧）</p><p>（2）实体层（bean/model/entity）：也叫模型层，entity层，就是数据库表的映射实体类，存放POJO对象；</p><p>（3）业务层（service）：也叫服务层，，包括XxxService.java(业务接口类)，XxxServiceImpl.java（业务实现类）；（可以在service文件夹下新建impl文件放业务实现类，也可以把业务实现类单独放一个文件夹下，更清晰）</p><p>（4）控制器层（controller）：实现与web前端的交互。</p><p>（5）额外的包有：config 配置类，interceptor 拦截器配置，util 工具类，等等其它包，根据项目需求分层。</p><p><img src="https://i.loli.net/2021/05/12/r5BvpwfxIgDQtSC.png" alt="image-20210512093729800"></p><p>注意：idea和eclipse不同，不能识别Java文件夹中的xml文件，如果直接放在resource下，可以扫描识别，但是放在resource中的Java文件不能编译识别。</p><p>和前端交互逻辑：</p><ol><li><p>前端的Http请求会到controller这一层，而controller层根据相应路由信息注解会跳转到相应的类。</p></li><li><p>在框架经过处理以后，最终调用的是mapper层。</p></li><li><p>在执行相应的Sql以后，将会依次返回到controller层，然后在Http的返回中将会以Json串对象返回给前端的调用方。</p></li><li><p>前端在Http的response中拿到返回的值，然后再进行一些处理。</p></li></ol><h1 id="实体类entity与持久层mapper"><a href="#实体类entity与持久层mapper" class="headerlink" title="实体类entity与持久层mapper"></a>实体类entity与持久层mapper</h1><h2 id="实体类entity创建"><a href="#实体类entity创建" class="headerlink" title="实体类entity创建"></a>实体类entity创建</h2><p>1、entity 包下创建 Goods 类<br>@Data 是lombok工具包含了set,get,toString 方法，相关详细请看该文章——链接如下：<a href="https://blog.csdn.net/qq_41254299/article/details/104176272">https://blog.csdn.net/qq_41254299/article/details/104176272</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.superclovers.spingboot.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品列表信息数据的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7123568729160306865L</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer pid;</span><br><span class="line">    <span class="keyword">private</span> String pname;</span><br><span class="line">    <span class="keyword">private</span> String pprices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久层接口mapper，添加抽象方法"><a href="#持久层接口mapper，添加抽象方法" class="headerlink" title="持久层接口mapper，添加抽象方法"></a>持久层接口mapper，添加抽象方法</h2><p>mapper包下创建GoodsMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.entity.GoodsEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理商品数据的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GoodsMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有商品列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 商品列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;GoodsEntity&gt; <span class="title">findList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一：<code>@Reponsitory</code>使用后,在启动类上需要添加<code>@MapperScan(“xxx.xxx.xxx.mapper”)</code>注解；<br>第二：<code>@Mapper</code>注解使用后相当于<code>@Reponsitory</code>加<code>@MapperScan</code>注解,会自动进行配置加载。</p><p><img src="https://i.loli.net/2021/05/12/4V2DBEZxLGozqfg.png" alt="image-20210512113059773"></p><h2 id="抽象方法匹配的映射，编写SQL语句"><a href="#抽象方法匹配的映射，编写SQL语句" class="headerlink" title="抽象方法匹配的映射，编写SQL语句"></a>抽象方法匹配的映射，编写SQL语句</h2><p>1、在 resources 创建 mapper 目录，接着创建 GoodsMapper.xml 文件<br>New ——&gt; File ——&gt; 文件名：GoodsMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.demo.mapper.GoodsMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 获取所有商品信息列表 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- List&lt;GoodsEntity&gt; findList();  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.entity.GoodsEntity&quot;</span>&gt;</span></span><br><span class="line">        select pid,pname,pprices from goods</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在 application.properties 中配置这些XML映射文件的位置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#3.Mybatis配置</span></span><br><span class="line"><span class="comment">#3.1配置映射类所在的包</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.example.demo.entity</span></span><br><span class="line"><span class="comment">#3.2mapper文件所在路径，这样写可匹配mapper目录下的所有mapper，包括其子目录下的</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>3、测试类中编写并执行单元测试<br>在 test 文件夹下的 mapper 下创建测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.entity.GoodsEntity;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.mapper.GoodsMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsMapperTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> GoodsMapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(mapper);</span><br><span class="line"></span><br><span class="line">        List&lt;GoodsEntity&gt; list = mapper.findList();</span><br><span class="line">        System.err.println(<span class="string">&quot;count=&quot;</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span> (GoodsEntity item : list) &#123;</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="业务层service与持久层mapper"><a href="#业务层service与持久层mapper" class="headerlink" title="业务层service与持久层mapper"></a>业务层service与持久层mapper</h1><h2 id="创建业务接口"><a href="#创建业务接口" class="headerlink" title="创建业务接口"></a>创建业务接口</h2><blockquote><ul><li>业务层用于控制业务流程和业务逻辑，从而保障数据安全。业务可能是由多个持久层功能组合而成，对于普通用户而言，表现为“某一个功能”；<br>在外部访问时，只允许访问业务层，不允许直接访问持久层。</li></ul></blockquote><p>创建业务层接口，添加抽象方法。在 service 包创建 IGoodsService （这里类名前加大写 I 表示业务接口类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.entity.GoodsEntity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理商品数据的业务层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGoodsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取热销商品列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 热销商品列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;GoodsEntity&gt; <span class="title">getHotList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现业务接口"><a href="#实现业务接口" class="headerlink" title="实现业务接口"></a>实现业务接口</h2><p>业务层实现类：在 service 的 impl 下创建 实现接口类 GoodsServiceImpl。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.service.imp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.entity.GoodsEntity;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.mapper.GoodsMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.service.IGoodsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsServiceImpl</span> <span class="keyword">implements</span> <span class="title">IGoodsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsMapper goodsMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取热销商品列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 热销商品列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;GoodsEntity&gt; <span class="title">getHotList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> goodsMapper.findList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 test 下创建 com.superclovers.springboot.service.GoodsServiceTests 测试类，编写并执行测试方法，测试业务层实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.entity.GoodsEntity;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsServiceTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IGoodsService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHotList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;GoodsEntity&gt; list = service.getHotList();</span><br><span class="line">        System.err.println(<span class="string">&quot;count=&quot;</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span> (GoodsEntity item : list) &#123;</span><br><span class="line">            System.err.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试类，可以得到：</p><p><img src="https://i.loli.net/2021/05/12/OYFoBLk36vxCAht.png" alt="image-20210512150813777"></p><h1 id="控制器层controller与持久层mapper"><a href="#控制器层controller与持久层mapper" class="headerlink" title="控制器层controller与持久层mapper"></a>控制器层controller与持久层mapper</h1><blockquote><ul><li>通过控制器接收用户的注册请求，当接收到请求后，控制器自身并不实现插入数据的操作，而是调用持久层对象来完成插入数据，最后，将结果响应给客户端。</li></ul></blockquote><h2 id="响应JSON数据的Result类创建"><a href="#响应JSON数据的Result类创建" class="headerlink" title="响应JSON数据的Result类创建"></a>响应JSON数据的Result类创建</h2><p>先创建 util 工具包层，然后创建 ResponseResult 类，用于向客户端响应JSON数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应JSON结果的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 响应的数据的类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer state;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">(Integer state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">(Integer state, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(Integer state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建控制器类"><a href="#创建控制器类" class="headerlink" title="创建控制器类"></a>创建控制器类</h2><p>创建控制类的基类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制器类的基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示响应成功，用户的操作是正确的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer SUCCESS = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 controller 包下创建 GoodsController 控制器类，并添加@RestController和@RequestMapping(“goods”)注解，然后在类中声明业务层对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.entity.GoodsEntity;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.service.IGoodsService;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.util.ResponseResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理商品相关请求的控制器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsController</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IGoodsService goodsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;hot&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult&lt;List&lt;GoodsEntity&gt;&gt; getHotList() &#123;</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        List&lt;GoodsEntity&gt; data = goodsService.getHotList();</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseResult&lt;&gt;(SUCCESS, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行启动类，打开浏览器，在地址栏中输入 <code>http://localhost:8090/demo/hot</code> 进行测试，观察在浏览器看到的响应结果是否正确。</p><p><img src="https://i.loli.net/2021/05/12/RFTuEHwGeJt98P6.png" alt="image-20210512152156772"></p><h1 id="整合前端界面"><a href="#整合前端界面" class="headerlink" title="整合前端界面"></a>整合前端界面</h1><h2 id="springboot-整合-ajax前端"><a href="#springboot-整合-ajax前端" class="headerlink" title="springboot 整合 ajax前端"></a>springboot 整合 ajax前端</h2><p>在静态资源的文件目录 resources/static/web/ 下创建 goods.html 编码页面</p><p>最后打开浏览器输入 <code>http://localhost:8090/web/goods.html</code> 页面数据显示，完成前后端的交互。</p><p><img src="https://i.loli.net/2021/05/12/1BQ6ufCL9UxXoNE.png" alt="image-20210512153843593"></p>]]></content>
    
    
    <summary type="html">IDEA中创建和启动SpringBoot应用 声明：本文中使用的是IDEA社区版 创建步骤 1、在file》setting》plugins中找到Spring Assistant，安装后重启idea 2、创建新的spring boot项目，步骤如下，然后点击next：（这里的spring assistant就相当于其它教程里的Spring Initializr） 设置好自己的包名和项目名，然后点击next；要选择的依赖：目录结构</summary>
    
    
    
    
    <category term="后端" scheme="https://chengling0824.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue基础</title>
    <link href="https://chengling0824.github.io/2021/04/18/vue%E5%9F%BA%E7%A1%80/"/>
    <id>https://chengling0824.github.io/2021/04/18/vue%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-17T16:43:29.000Z</published>
    <updated>2021-05-06T16:03:36.388Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。</p></blockquote><h1 id="vue响应式系统"><a href="#vue响应式系统" class="headerlink" title="vue响应式系统"></a>vue响应式系统</h1><p>Vue为MVVM框架，MVVM是前端页面的分层开发思想，主要关注于 视图层 分离。也就是说：MVVM把前端的视图层，分为了三部分 Model, View,  ViewModel</p><ul><li>Model 是 页面中，需要用到的数据</li><li>View 是页面中的HTML结构；</li><li>ViewModel 是 一个 中间的调度者,提供了双向数据绑定的概念；</li></ul><p>当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。</p><p>在响应式系统中，Vue会为数据模型data的每一个属性新建一个订阅中心作为发布者，而监听器watch、计算属性computed、视图渲染template/render三个角色同时作为订阅者，对于监听器watch，会直接订阅观察监听的属性，对于计算属性computed和视图渲染template/render，如果内部执行获取了data的某个属性，就会执行该属性的getter方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的setter方法，从而完成该属性的发布通知，通知所有订阅者进行更新。</p><h1 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h1><blockquote><p>指令带有前缀 v-，以表示它们是 Vue 提供的特殊 attribute。它们会在渲染的 DOM 上应用特殊的响应式行为。</p></blockquote><h2 id="v-clock-解决文字闪动的问题"><a href="#v-clock-解决文字闪动的问题" class="headerlink" title="v-clock 解决文字闪动的问题"></a>v-clock 解决文字闪动的问题</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol><li>提供样式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[v-clock]&#123;</span><br><span class="line">    display:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在插值表达式所在的标签中添加v-clock指令<br>先通过样式隐藏内容，然后在内存中进行值的替换，替换好后显示最终的结果。（解决了文字闪动的问题）</li></ol><h2 id="文本插值与-v-text、v-html、v-pre"><a href="#文本插值与-v-text、v-html、v-pre" class="headerlink" title="文本插值与 v-text、v-html、v-pre"></a>文本插值与 v-text、v-html、v-pre</h2><p>v-text<br>v-html<br>v-pre : 显示原始信息，跳过编译过程</p><h2 id="数据响应式与-v-once"><a href="#数据响应式与-v-once" class="headerlink" title="数据响应式与 v-once"></a>数据响应式与 v-once</h2><blockquote><p>数据响应式：数据和 DOM 被建立某种关联，数据的变化导致页面内容的变化</p></blockquote><p>v-once：只编译一次，不具有响应式功能</p><h2 id="属性绑定-v-bind-："><a href="#属性绑定-v-bind-：" class="headerlink" title="属性绑定 v-bind / ："></a>属性绑定 v-bind / ：</h2><h3 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h3><p><strong>对象语法</strong>：<code>v-bind:class(类名: data中属性，值为true就会添加该样式)&quot;</code></p><p>v-bind:class={类名1:data中的属性1，类名2:data中的属性2}</p><p><strong>数组语法</strong>：class类名放在<strong>data</strong>属性中当做值，然后将<strong>data</strong>中的值放在数组中渲染给元素<code> v-bind:class&quot;[data属性名1，data属性名2]&quot;</code></p><p><strong>style绑定</strong>：<code>v-bind:style&#123;color颜色名: data中的属性名&#125;</code>或<code>v-bind:style=&quot;[data属性名1，data属性名2]&quot;</code></p><h2 id="双向数据绑定-v-model"><a href="#双向数据绑定-v-model" class="headerlink" title="双向数据绑定 v-model"></a>双向数据绑定 v-model</h2><p>实现<strong>表单输入</strong>和应用状态之间的双向绑定</p><p><code>v-model=&#39;msg&#39;</code>相当于<code>v-bind:value=&quot;msg&quot; v-on:input=&#39;msg=$event.target.value&#39;</code>,实时更新msg的值</p><h2 id="事件监听-v-on"><a href="#事件监听-v-on" class="headerlink" title="事件监听 v-on / @"></a>事件监听 v-on / @</h2><p><code>@click=&#39;num++&#39;</code> （num在data中定义）</p><p><code>@click=&#39;handle&#39;</code>或<code>@click=&#39;handle()&#39;</code>    （handle函数在methods中定义）</p><blockquote><p>在methods中，this是vue的实例对象</p></blockquote><h2 id="分支循环结构"><a href="#分支循环结构" class="headerlink" title="分支循环结构"></a>分支循环结构</h2><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><p>v-if</p><p>v-else</p><p>v-else-if</p><p>v-show</p><h3 id="循环结构-v-for"><a href="#循环结构-v-for" class="headerlink" title="循环结构 v-for"></a>循环结构 v-for</h3><p>v-for遍历数组：<code>v-for=&quot;(item, index) in list :key=&quot;item.id&quot;&quot;</code></p><p>v-for遍历对象：<code> v-for (属性值v, 属性名k，索引 i )in 遍历的对象</code></p><h2 id="时间修饰符"><a href="#时间修饰符" class="headerlink" title="时间修饰符"></a>时间修饰符</h2><h3 id="stop-阻止冒泡"><a href="#stop-阻止冒泡" class="headerlink" title=".stop 阻止冒泡"></a>.stop 阻止冒泡</h3><p>调用<code>event.stopPropagation( )</code></p><h3 id="prevent-阻止默认行为"><a href="#prevent-阻止默认行为" class="headerlink" title=".prevent 阻止默认行为"></a>.prevent 阻止默认行为</h3><p>调用<code>event.preventDefault( )</code></p><p><code> v-on:click.prevent.self</code> 阻止所有点击</p><p><code>v-on:click.self.prevent</code> 阻止自身的点击</p><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><p>.capture 添加事件侦听器时使用capture模式</p><p>.self 事件从侦听器绑定元素本身触发时才触发回调</p><p>.once 只触发一次</p><p>.passive</p><h2 id="按键修饰符-keyup"><a href="#按键修饰符-keyup" class="headerlink" title="按键修饰符 .keyup"></a>按键修饰符 .keyup</h2><blockquote><p>在监听键盘事件时，我们需要检查详细的按键。Vue允许为<code>v-on</code>在监听键盘时添加按键修饰符：</p></blockquote><h3 id="按键码"><a href="#按键码" class="headerlink" title="按键码"></a>按键码</h3><p><code>.enter</code>，<code>.tab</code>，<code>.delete</code>(捕获‘删除’键和‘退格’键)，<code>.esc</code></p><p><code>.up</code>，<code>.down</code>，<code>.left</code>，<code>.right</code></p><h3 id="自定义按键修饰符"><a href="#自定义按键修饰符" class="headerlink" title="自定义按键修饰符"></a>自定义按键修饰符</h3><p>可以通过<code>config.keyCodes</code>对象自定义<strong>按键修饰符别名</strong>，如<code>Vue.config.keyCodes.f1 = 11</code></p><h1 id="自定义指令、计算、侦听、过滤器、生命周期"><a href="#自定义指令、计算、侦听、过滤器、生命周期" class="headerlink" title="自定义指令、计算、侦听、过滤器、生命周期"></a>自定义指令、计算、侦听、过滤器、生命周期</h1><h2 id="基于vue的表单操作"><a href="#基于vue的表单操作" class="headerlink" title="基于vue的表单操作"></a>基于vue的表单操作</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>input 单行文本</p><p>textarea 多行文本</p><p>select 下拉多选</p><p>type=”radio” 单选框</p><p>type=”checkbox” 多选框</p><blockquote><p>表单元素被选中的规则： </p><p>1：通过v-model绑定data中的属性，该属性中的值就是表单对象中要显示的内容。 </p><p>2：data中属性可以是单个值，多个值则放在数组中，每一项用’ ‘引号包裹，逗号隔开。  </p><p>3：多选框规律：因为v-model绑定了data中的属性，该元素中的value=1值，对应的就是data属性数组中的值，有几个多选框就会显示几个。</p></blockquote><h3 id="表单域修饰符"><a href="#表单域修饰符" class="headerlink" title="表单域修饰符"></a>表单域修饰符</h3><p>v-model.number：转化为数值，方便运算</p><p>v-model.trim：去掉开始和结尾的空格</p><p>v-model.lazy：将input事件转化为change事件（失去焦点时触发）</p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h3 id="全局定义自定义指令"><a href="#全局定义自定义指令" class="headerlink" title="全局定义自定义指令"></a>全局定义自定义指令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义指令的语法规则</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>&#123;</span><br><span class="line">inserted:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line"><span class="comment">//获取元素的焦点</span></span><br><span class="line">el.focus();</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义指令用法</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; v-focus&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带参数的自定义指令</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;color&#x27;</span>&#123;</span><br><span class="line">    <span class="comment">//bind：绑定事件函数</span></span><br><span class="line">bind:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">el.style.backgroundColor = binding.value.color;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;带参数的自定义指令的用法</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; v-color&#x3D;&#39;&#123;color:&quot;orange&quot;&#125;&#39;&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义局部指令"><a href="#自定义局部指令" class="headerlink" title="自定义局部指令"></a>自定义局部指令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data:&#123;&#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//通过directive创建的指令为局部指令，Vue.directive为全局指令</span></span><br><span class="line">    directives:&#123;</span><br><span class="line">        focus:</span><br><span class="line">        inserted:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    el.focus();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><blockquote><p>计算属性可以使模板内容更加简洁，更易维护</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter（vm.reversedMessage）</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于格式逻辑复杂的函数，使用计算属性能使内容更加简洁。compuetd计算属性名，对应{ }对象，对象中的属性名对应了处理函数<strong>function</strong>,  该函数的处理结果能返回给计算属性。</p><h3 id="计算属性与方法的区别"><a href="#计算属性与方法的区别" class="headerlink" title="计算属性与方法的区别"></a>计算属性与方法的区别</h3><p>计算属性基于依赖进行缓存（如果值不变，则直接从缓存中拿结果，不进行二次调用），效率高，性能好</p><p>方法不缓存（用一次调一次），性能开销较大</p><h3 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h3><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p><h2 id="侦听器-watch"><a href="#侦听器-watch" class="headerlink" title="侦听器 watch"></a>侦听器 watch</h2><blockquote><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。<strong>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</strong></p></blockquote><p>侦听属性watch一般用于异步或者开销较大的操作，比如通过ajax接口拿数据，和settimeout异步任务</p><p><img src="https://i.loli.net/2021/04/22/onLZrgzEj4lmekc.png" alt="img"></p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><blockquote><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值和 <code>v-bind</code> 表达式</strong> (后者从 2.1.0+ 开始支持)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;过滤器的使用</span><br><span class="line">&lt;!-- 在双花括号中 --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 &#96;v-bind&#96; 中 --&gt;</span><br><span class="line">&lt;div v-bind:id&#x3D;&quot;rawId | formatId&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义过滤器（全局）"><a href="#自定义过滤器（全局）" class="headerlink" title="自定义过滤器（全局）"></a>自定义过滤器（全局）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">&#x27;过滤器名称&#x27;</span>，<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="comment">//过滤器业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    filter:&#123;</span><br><span class="line">        过滤器名称:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><blockquote><p>Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</p></blockquote><p>实例的生命周期-分为3个大阶段 </p><p>阶段一渲染： </p><p>阶段二数据改动，更新数据：</p><p>阶段三：销毁vue实例会触发， 该阶段中，我们主要记住mounted函数，以为页面数据已经渲染完成，我们之后会常用它调用ajax接口去渲染页面数据。</p><ul><li><strong>beforeCreate（创建前)</strong><br>在数据观测和初始化事件还未开始</li><li><strong>created（创建后）</strong><br>完成数据观测，属性和方法的运算，初始化事件，el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</li><li><strong>beforeMount(挂载前)</strong></li><li><strong>mount*********</strong>&lt;。)#)))≦-/<em>ed(挂载后)</em>*<br>DOM 渲染在 mounted 中就已经完成。</li><li><strong>beforeUpdate（更新前）</strong><br>在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li><li><strong>updated（更新后）</strong><br>在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li><strong>beforeDestroy（销毁前）</strong><br>在实例销毁之前调用。实例仍然完全可用。</li><li><strong>destroyed（销毁后）</strong><br>在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li></ul><p>同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p><img src="https://i.loli.net/2021/04/22/x7UWvdZgwSa3jNF.png" alt="img" style="zoom: 50%;" /><h1 id="vue数据处理"><a href="#vue数据处理" class="headerlink" title="vue数据处理"></a>vue数据处理</h1><h2 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h2><p><img src="https://i.loli.net/2021/04/22/lG2T8ReQrwabSqn.png" alt="img"></p><h2 id="动态处理响应式数据-Vue-set"><a href="#动态处理响应式数据-Vue-set" class="headerlink" title="动态处理响应式数据 Vue.set"></a>动态处理响应式数据 Vue.set</h2><p>vm.$set(参数1：vue中的属性，可以是数组或者对象， 参数2：可以是序号也可以是属性名， 参数3：需要替换的内容)，完成数据修改。</p><p>如果是对象：(参数1：修改的对象， 参数2， 属性名， 属性值)，</p><p>如果是数组(参数1：修改的数组， 参数二，数组的第几项,索引，参数3：属性值)</p><p><img src="https://i.loli.net/2021/04/22/jNtI91OopqARiQf.png" alt="img"></p><h1 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h1><blockquote><p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树。</p><p>组件是可复用的 Vue 实例。web components通过创建封装好功能的定制元素，可以使得我们尽可能多的重用代码。</p></blockquote><h2 id="全局注册组件"><a href="#全局注册组件" class="headerlink" title="全局注册组件"></a>全局注册组件</h2><p>全局组件通过Vue.component创建。其中，<strong>data必须是一个函数</strong>，数据必须通过return给返回来， template中有且只有一个根元素，负责渲染组件真实的元素标签，以及事件绑定等操作，有单独的handler函数， 子组件的挂载方式为在app容器中挂载就能渲染到页面上了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;组件名称&#x27;</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;&#125;</span><br><span class="line">  &#125;, <span class="comment">//组件数据</span></span><br><span class="line">  template: <span class="string">&#x27;&#x27;</span> <span class="comment">//组件模板内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;button-counter&#x27;</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 自定义组件的使用 --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;components-demo&quot;&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;&#x2F;button-counter&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h2 id="局部注册组件"><a href="#局部注册组件" class="headerlink" title="局部注册组件"></a>局部注册组件</h2><p>局部组件使用var关键字声明<strong>创建</strong>的，它也有自己的data函数， 和template模板渲染，但是他必须放在vm父实例对象中component这个组件中去注册<strong>配置</strong>好，才能<strong>挂载</strong>到app中去显示。</p><p> 因为是局部组件，只能在父组件中使用，其他全局组件使用局部组件会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    component:&#123;</span><br><span class="line">        <span class="string">&#x27;component-a&#x27;</span>:ComponentA,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><p>子组件通过props定义好自定义属性，通过它就能接收父组件data中的数据了</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;pmsg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 2.子通过:title接收数据 --&gt;</span><br><span class="line">&lt;menu-item :title&#x3D;&#39;ptitle&#39; content&#x3D;&#39;hello&#39;&gt;&lt;&#x2F;menu-item&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;menu-item&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">//3.必须在props声明:title属性，才能在template中去挂载</span></span><br><span class="line">props:[<span class="string">&#x27;title&#x27;</span>,<span class="string">&#x27;content&#x27;</span>],</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            msg:<span class="string">&#x27;子组件本身的数据&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//4.在template中可以使用子属性title</span></span><br><span class="line">    template:<span class="string">&#x27;&lt;div&gt;&#123;&#123;msg + &quot;----&quot; + title + &quot;----&quot; + content&#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        <span class="comment">//1.父组件声明数据</span></span><br><span class="line">        pmsg:<span class="string">&#x27;父组件的内容&#x27;</span>,</span><br><span class="line">        ptitle:<span class="string">&#x27;动态绑定属性&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>props属性值类型</strong>：</p><p>1、字符串String</p><p>2、数值number（加了 :冒号是number类型，不加为string类型）</p><p>3、布尔值类型Boolean（加了 :冒号是boolean类型，不加为string）</p><p>4、数组array</p><p>5、对象object</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">      &lt;!-- 2：子组件在挂载的时候，接收父组件的数据， number和boolean是自己的 --&gt;</span><br><span class="line">      &lt;son-ming</span><br><span class="line">        :is-son&#x3D;&quot;fantherInfo&quot;</span><br><span class="line">        :son-str&#x3D;&quot;fatherStr&quot;</span><br><span class="line">        :son-number&#x3D;&quot;12&quot;</span><br><span class="line">        :son-boolean&#x3D;&quot;true&quot;</span><br><span class="line">        :son-array&#x3D;&quot;fatherArray&quot;</span><br><span class="line">        :son-object&#x3D;&quot;fatherObj&quot;</span><br><span class="line">      &gt;&lt;&#x2F;son-ming&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;sonMing&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 3：必须先以驼峰命名方式接收，自定义属性名，才能在自己的template中使用</span></span><br><span class="line">    props: [</span><br><span class="line">        <span class="string">&quot;is-son&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sonStr&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sonNumber&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sonBoolean&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sonArray&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sonObject&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">``</span>,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        <span class="comment">// 1:父组件提供了5大类型的数据</span></span><br><span class="line">        fantherInfo: <span class="string">&quot;是爸爸的儿子&quot;</span>,</span><br><span class="line">        fatherStr: <span class="string">&quot;我是字符串&quot;</span>,</span><br><span class="line">        fatherArray: [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>],</span><br><span class="line">        fatherObj: &#123;</span><br><span class="line">            name: <span class="string">&quot;大明爸爸&quot;</span>,</span><br><span class="line">            age: <span class="number">46</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h2><p>子组件通过自定义事件向父组件传递信息，父组件监听子组件的事件</p><p>子向父传值，其实就是子组件修改了父组件中的数据， 是通过子组件的**$emit**绑定一个自定义事件名称， 这个自定义事件名称将会在子组件挂载的时候，会去调用父组件中的事件处理函数， 从而实现了子组件去修改父组件中的内容</p><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- 4：此时就能够，点击子，触发父，会让父组件中的文字变大 --&gt;</span><br><span class="line">    &lt;div :style&#x3D;&#39;&#123;fontSize: fSize + &quot;px&quot;&#125;&#39;&gt;&#123;&#123;info&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 2：通过@接收这个属性名，这个属性名会触发父组件的处理函数 --&gt;</span><br><span class="line">    &lt;son-ming @get-father-size&#x3D;&quot;fatherSize&quot;&gt;&lt;&#x2F;son-ming&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;sonMing&quot;</span>, &#123;</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            sonInfo: <span class="string">&quot;我是小明，点我让爸爸变胖&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 1：发布自定义事件：子组件自己在template元素中通过$emit绑定某个属性名</span></span><br><span class="line">    template: <span class="string">`&lt;div @click=&#x27;$emit(&quot;get-father-size&quot;)&#x27;&gt;&#123;&#123;sonInfo&#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        info: <span class="string">&quot;爸爸大明&quot;</span>,</span><br><span class="line">        fSize: <span class="number">20</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">// 3：父组件处理自己的事件处理函数</span></span><br><span class="line">        fatherSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.fSize += <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>携带参数的方式：</p><p>1、发布自定义事件时，通过$emit(声明自定义事件名称 , 要携带的参数)</p><p>2、在父组件处理函数中，用val接收子组件传递过来的值 function(val){ }</p><h2 id="兄弟组件间数据交互"><a href="#兄弟组件间数据交互" class="headerlink" title="兄弟组件间数据交互"></a>兄弟组件间数据交互</h2><p>在一个页面中有2个vue.component全局子组件，能通过新建一个通信中心，实现数据共享，通信中心就是新new Vue一个对象作为事件处理中心</p><p>示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.在父组件中，通过hub.$off可以解绑兄弟组件的事件，实现事件销毁</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data:&#123;&#125;,</span><br><span class="line">  method:&#123;</span><br><span class="line">      handle:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          hub.$off(<span class="string">&#x27;tom-event&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);  </span><br><span class="line">    </span><br><span class="line"><span class="comment">//1.创建一个中心管理组件</span></span><br><span class="line"><span class="keyword">var</span> hub = <span class="keyword">new</span> Vue();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.Vue.component创建子组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;test-tom&#x27;</span>,&#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//3.在template模板中绑定自己的事件函数，通过它触发兄弟组件的处理函数并传值</span></span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;button @click=&#x27;handle&#x27;&gt;&lt;/button&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        handle:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//hub.$emit挂载兄弟组件的事件名称</span></span><br><span class="line">            hub.$emit(<span class="string">&#x27;兄弟组件&#x27;</span>,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//监听事件</span></span><br><span class="line">        <span class="comment">//hub.$on触发自己的事件函数</span></span><br><span class="line">        hub.$on(<span class="string">&#x27;tom-event&#x27;</span>,<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.num += val;</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h3 id="组件插槽"><a href="#组件插槽" class="headerlink" title="组件插槽"></a>组件插槽</h3><p>在组件template中<slot></slot>用于接收子组件内容，相当于一个占位符</p><p>如果子组件没有传值，就会渲染slot插槽中的默认值</p><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><blockquote><p>也叫有名字的插槽，如果在子组件挂载的时候，slot声明了name就会使用子组件中同名的插槽去渲染该元素， 如果没有就会渲染到默认的无名插槽中</p></blockquote><p>1、在自定义组件的template中用语义化标签包裹slot具名插槽（有name的插槽）</p><p>2、在app中渲染组件，如果元素调用slot=插槽name，就会将内容插入到有名字的插槽中</p><p>3、无名的slot插槽，在app中渲染组件，如果元素调用slot，并且没有名称，就会将内容插入到无名字的插槽中</p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽，可以理解为二次加工的方法，通过slot把遍历好的每一项数据传递给插槽，而插槽通过props接收了list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F;1.组件中通过props绑定属性名，将list数据传递给组件渲染</span><br><span class="line">    &lt;fruit-list :list&#x3D;&quot;list&quot;&gt;</span><br><span class="line">        &#x2F;&#x2F;2.组件渲染就能通过slot-scope别名的方式接收到遍历的每项数据</span><br><span class="line">    &lt;template slot-scope&#x3D;&#39;slotProps&#39;&gt;</span><br><span class="line">&#x2F;&#x2F;3.子组件通过info属性绑定接收item，并渲染数据</span><br><span class="line">&#x2F;&#x2F;这里的slotProps.info.id &#x3D; list.item.id，这样就能通过修改id，让指定的元素加粗高亮</span><br><span class="line">        &lt;strong v-if&#x3D;&#39;slotProps.info.id&#x3D;&#x3D;3&#39; class&#x3D;&quot;current&gt;&quot;&gt;&#123;&#123;slotProps.info.name&#125;&#125;&lt;&#x2F;strong&gt;</span><br><span class="line">&lt;span v-else&gt;&#123;&#123;slotProps.info.name&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;fruit-list&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;fruit-list&#x27;</span>,&#123;</span><br><span class="line">    props:[<span class="string">&#x27;list&#x27;</span>],</span><br><span class="line">    template:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;li :key=&#x27;item.id&#x27; v-for=&#x27;item in list&#x27;&gt;</span></span><br><span class="line"><span class="string">&lt;slot :info=&#x27;item&#x27;&gt;&#123;&#123;item.name&#125;&#125;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        list:[&#123;</span><br><span class="line">            id:<span class="number">1</span>,</span><br><span class="line">            name:<span class="string">&#x27;apple&#x27;</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="前后端交互概述与URL地址格式"><a href="#前后端交互概述与URL地址格式" class="headerlink" title="前后端交互概述与URL地址格式"></a>前后端交互概述与URL地址格式</h2><h3 id="前后端交互模式"><a href="#前后端交互模式" class="headerlink" title="前后端交互模式"></a>前后端交互模式</h3><p>接口调用方式：原生ajax、基于jquery的ajax、fetch、axios</p><p>传统url地址是： 协议:<em>//IP地址:端口/路径/？查询参数/#锚点。</em>  </p><p>http请求方式：GET请求，POST添加，PUT修改，DELETE修改</p><h2 id="异步编程问题"><a href="#异步编程问题" class="headerlink" title="异步编程问题"></a>异步编程问题</h2><p>在异步调用的时候，多次异步调用的结果顺序不确定，异步调用结果如果存在依赖需要嵌套。</p><p>但嵌套时会形成回调地狱。。。</p><h2 id="Pormise概述与基本用法"><a href="#Pormise概述与基本用法" class="headerlink" title="Pormise概述与基本用法"></a>Pormise概述与基本用法</h2><p>Promise是异步编程的一种解决方案，从语法上讲，Promise是一个对象，从他可以获取异步操作的消息。</p><p>Promise基本用法如下：</p><ul><li>实例化Promise对象，构造函数中传递函数，该函数中用于处理异步任务</li><li>resolve和reject两个参数用于处理成功和失败两种情况，并通过p.then获取处理结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 成功时调用 resolve()</span></span><br><span class="line">    <span class="comment">// 失败时调用 reject()</span></span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 从resolve得到正常结果</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">info</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 从reject得到错误信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise发送Ajax请求"><a href="#Promise发送Ajax请求" class="headerlink" title="Promise发送Ajax请求"></a>Promise发送Ajax请求</h2><p>基于Promise发送AJAX请求的步骤如下：</p><ol><li>封装queryData函数，接收一个请求地址，创建promise对象。在里面创建原生ajax对象，监听onreadystatechange请求结果。如果成功就将ajax请求结果打印，如果请求失败，就将错误信息打印。</li><li>调用queryData发起具体请求，.then中第一个回调函数打印的是成功的结果，第二个打印错误的请求结果</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于Promise发送AJAX请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>&#123;</span><br><span class="line">                <span class="comment">// 处理正常情况</span></span><br><span class="line">               resolve(xhr.responseText);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//处理异常情况</span></span><br><span class="line">                reject(<span class="string">&#x27;服务器错误&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.open(<span class="string">&#x27;get&#x27;</span>,url);</span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queryData(<span class="string">&#x27;http://localhost:8080/data&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">info</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(info);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>发送多个ajax请求时：</p><p>直接调用queryData发起第一个请求，第一个回调函数处理第一个处理结果，return中发起第二个请求，在下一次的then中打印请求二的结果，以此类推。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queryData(<span class="string">&#x27;http://localhost:8080/data&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> queryData(<span class="string">&#x27;http://localhost:8080/data1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data1</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data1);</span><br><span class="line">    <span class="keyword">return</span> queryData(<span class="string">&#x27;http://localhost:8080/data2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data2);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise的then方法参数中的函数的返回值"><a href="#Promise的then方法参数中的函数的返回值" class="headerlink" title="Promise的then方法参数中的函数的返回值"></a>Promise的then方法参数中的函数的返回值</h2><ol><li><p>返回 Promise 对象</p><p>返回的该示例对象会调用下一个then。如上例所示</p></li><li><p>返回普通值</p><p>返回的普通值会直接传递给下一个then中的函数</p></li></ol><h2 id="Promise常用API"><a href="#Promise常用API" class="headerlink" title="Promise常用API"></a>Promise常用API</h2><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li>p.then() 得到异步任务的正确结果</li><li>p.catch() 获取异常信息</li><li>p.finally() 成功与否都会执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queryData()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;finished&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果</p><p>Promise.race() 并发处理多个异步任务，只要有一个任务完成就能得到结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = queryData(<span class="string">&#x27;http://localhost:8080/a1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = queryData(<span class="string">&#x27;http://localhost:8080/a2&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p3 = queryData(<span class="string">&#x27;http://localhost:8080/a3&#x27;</span>);</span><br><span class="line"><span class="comment">// all方法只能返回一个结果</span></span><br><span class="line"><span class="built_in">Promise</span>.all(p1,p2,p3).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// race方法能返回所有结果</span></span><br><span class="line"><span class="built_in">Promise</span>.race(p1,p2,p3).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="数据请求：Fetch-API"><a href="#数据请求：Fetch-API" class="headerlink" title="数据请求：Fetch API"></a>数据请求：Fetch API</h1><h2 id="FetchAPI概述和基本用法"><a href="#FetchAPI概述和基本用法" class="headerlink" title="FetchAPI概述和基本用法"></a>FetchAPI概述和基本用法</h2><h3 id="fetch概述"><a href="#fetch概述" class="headerlink" title="fetch概述"></a>fetch概述</h3><ol><li><p>基本特性</p><ul><li>更加简单的数据获取方式，功能更强大、更灵活，可以看作是xhr的升级版</li><li>基于promise实现</li></ul></li><li><p>语法结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(url).then(fn2)</span><br><span class="line">.then(fn3)</span><br><span class="line">...</span><br><span class="line">        .catch(fn)</span><br></pre></td></tr></table></figure></li></ol><h3 id="fetch基本用法"><a href="#fetch基本用法" class="headerlink" title="fetch基本用法"></a>fetch基本用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;/abc&#x27;</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//text()方法属于fetchAPI的一部分，返回一个promise对象，用于获取后台数据</span></span><br><span class="line">    <span class="keyword">return</span> data.text();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里方获得最终数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="GET、DELETE、POST、PUT"><a href="#GET、DELETE、POST、PUT" class="headerlink" title="GET、DELETE、POST、PUT"></a>GET、DELETE、POST、PUT</h2><p><img src="https://i.loli.net/2021/05/06/qSswZhcoryfRa7H.png" alt="img"></p><p>1：get方式：</p><p>1.1 传统方式：页面中请求地址后面?id=123，这是传统的请求方式， 也是在本体中data.text把数据返回给打印，  </p><p>1.2：resful风格：请求地址后面直接/123携带id，其他都是一致的。 但是服务器中不一样app.get(‘/books/:id’)他能动态接收id </p><p>2：delete 删除：</p><p>1：页面请求：直接在请求地址后面携带ID， 但是必须声明method:delete方式为删除，其他是一致的。 </p><p>2：服务器接口：app.delete（‘/books/:id’，接收到id </p><p>3：post方式：</p><p>1：传统方式：普通的请求地址， method：post请求方式，body：uname=lisi&amp;pwd=123456， 请求体携带请求参数， headers：{Content-Type:’application/x-www-form-urlencoded’}请求头信息，其他一致。</p><p>4：put方式：</p><p>1：页面请求：请求地址后面携带id，method：put请求方式为put， body：JSON.stringify({uname:’xx’, pwd:’xx’}),  headers：{Content-Type:’application/x-www-form-urlencoded’} 请求头信息，其他一致. </p><p>resful风格：普通的请求地址，method请求方式， </p><p>body：JSON.stringify({uname:’xx’, pwd:’xx’})。 </p><p>需要通过转换成json字符串。headers：{Content-Type:application./json}json类型的请求头， 其他一致 </p><p>服务器接口：app.put(‘/books/:id’,),其他是普通的 </p><p>params和req.body的区别： </p><p>req.params是请求地址后面携带的参数， </p><p>【比如req.params.id就是请求地址后面/books/123的这个123id地址】 </p><p>req.body 是请求体body中的信息： </p><p>【比如req.body.uname，就是请求体body请求体对象中的属性, body: JSON.stringify({uname:’’xx’, pwd:’xx’})】 </p><p>总结 </p><p>resful和传统的服务器区别：</p><p> 区别就是传统就是普通的请求地址，后面不携带任何参数，  在请求页面中的请求地址后面直接携带，或者在请求body中携带。 </p><p>resful接口的后面:/id可以接受id，在请求页面中通过body传递， 必读设置请求头。区别就是接口多了:/id接收id， </p><p>resful调用接口和传统调用的区别：</p><p>页面请求中body不一样而已， 普通的是一行写完，body:’uanme=lis&amp;pwd=123’,  </p><p>而resful是body中通过body:JSON.stringify以键值对形式传递数据的uname:’zs’。</p><h2 id="FetchAPI响应数据格式"><a href="#FetchAPI响应数据格式" class="headerlink" title="FetchAPI响应数据格式"></a>FetchAPI响应数据格式</h2><p>在请求页面中通过data.json能把json字符串转换为对象类型， </p><p>类似于JSON.parse方法,如果不转换表面上看似一样的，但是json()转换出来的是对象类型， 能通过对象.属性获得值。</p><p>而不转换是string类型，值会是undefined</p><p><img src="https://i.loli.net/2021/05/06/2CzD3tjbeWJic1y.png" alt="img"></p><h1 id="数据请求：axios"><a href="#数据请求：axios" class="headerlink" title="数据请求：axios"></a>数据请求：axios</h1><h2 id="axios概述和基本用法"><a href="#axios概述和基本用法" class="headerlink" title="axios概述和基本用法"></a>axios概述和基本用法</h2><h3 id="axios基本特性"><a href="#axios基本特性" class="headerlink" title="axios基本特性"></a>axios基本特性</h3><p>axios是一个基于promise用于浏览器和node.js的http客户端</p><p>它具有以下特征：</p><p>1、支持浏览器和node.js </p><p>2、支持promise </p><p>3、能拦截请求和响应 </p><p>4、自动转化JSON数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;http://localhost:3000/adata&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(ret.data) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过axios.get(请求地址/接口地址).then就能拿到ret接口返回的数据，  </p><p>可以简化成ret.data就是要拿到的接口具体的数据：</p><h3 id="axios的GET和DELETE请求传参"><a href="#axios的GET和DELETE请求传参" class="headerlink" title="axios的GET和DELETE请求传参"></a>axios的GET和DELETE请求传参</h3><p>页面请求方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过url请求参数</span></span><br><span class="line">axios.get(<span class="string">&#x27;/adata?id=123&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">ret</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过params选项传递参数</span></span><br><span class="line">axios.get(<span class="string">&#x27;/adata&#x27;</span>,&#123;</span><br><span class="line">    param:&#123;</span><br><span class="line">        id:<span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">ret</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//axios delete请求传参</span></span><br><span class="line">axios.delete(<span class="string">&#x27;url&#x27;</span>,&#123;</span><br><span class="line">    params:&#123;&#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>服务器处理方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;axios&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;axios get 传参&#x27;</span> + req.query.id)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(<span class="string">&#x27;axios/:id&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;axios get (Restful) 传参&#x27;</span> + req.params.id)</span><br><span class="line">&#125;)</span><br><span class="line">app.delete(<span class="string">&#x27;/axios&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;axios get 传参&#x27;</span> + req.query.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios的POST和PUT请求传参"><a href="#axios的POST和PUT请求传参" class="headerlink" title="axios的POST和PUT请求传参"></a>axios的POST和PUT请求传参</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过选项传递参数 （默认传递json数据）</span></span><br><span class="line">axios.post(<span class="string">&#x27;adata&#x27;</span>,&#123;</span><br><span class="line">    uname:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    pwd:<span class="number">123</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过URLSearchParams传递参数</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">params.append(<span class="string">&#x27;params1&#x27;</span>,<span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">params.append(<span class="string">&#x27;params2&#x27;</span>,<span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line">axios.post(<span class="string">&#x27;/api/test&#x27;</span>,params).then(<span class="function"><span class="params">ret</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.put(<span class="string">&#x27;/adata/123&#x27;</span>,&#123;</span><br><span class="line">    uname:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    pwd:<span class="number">123</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">ret</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios响应结果与全局配置"><a href="#axios响应结果与全局配置" class="headerlink" title="axios响应结果与全局配置"></a>axios响应结果与全局配置</h3><p><img src="https://i.loli.net/2021/05/07/xjfh29ROaIKcvrF.png" alt="img"></p><h3 id="axios拦截器用法"><a href="#axios拦截器用法" class="headerlink" title="axios拦截器用法"></a>axios拦截器用法</h3><p>1：请求拦截器：axios.interceptors.request.use(function(config) { console.log(config<br>就是请求对象，它能拿到关于页面的请求信息，我们可以把token设置在请求中config.headers.mytoken=’nihao’， </p><p>注意mytoken已经在服务器中的跨图请求中设置好了，使用才能用，但是必须通过return将这个参数给return出去) })，<br>第二个function打印的是错误信息。  </p><p>2：响应拦截器：axiosinterceptors.response.use,<br>可以在这个响应拦截中将res.data的返回值给data，<br>这样以后在请求中可以直接通过data拿到数据，<br>而不用res.data.但是也补习return出去，</p><p>3：服务器接口，app.get(‘/adata’, (req, res) =&gt; {})，是一个普通的接口处理</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53099938178041779a1ab366503ed3b4~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h2 id="async函数基本用法"><a href="#async函数基本用法" class="headerlink" title="async函数基本用法"></a>async函数基本用法</h2><p>1：async简化函数封装异步发起数据请求： 函数封装的时候在前面加上async，<br>在调用axios.get发起数据请求的时候前面加上await， 他的返回结果被变量接收，<br>需要将这个变量return出去【其实就是接口返回的数据，被return出去了，<br>这样后面调用这函数封装， 就能感到数据】</p><p>2：async简化promise对象， 在封装函数前面加上async， 在函数里面创建peomsie对象，<br>该对象中有一个异步任务， 异步任务执行的结果赋值给ret，然后return个函数封装，<br>这样调用函数通过.then就能拿到异步中的执行结果。</p><p><img src="https://i.loli.net/2021/05/07/4QtdN2W8wP3IcSg.png" alt="img"></p><h3 id="async函数处理多个异步请求"><a href="#async函数处理多个异步请求" class="headerlink" title="async函数处理多个异步请求"></a>async函数处理多个异步请求</h3><p>在一个async中可以同时调用多次await拿到异步任务的返回值，<br>传给第二个接口，当做形参一并传给服务器，<br>该案例中接口1中返回的是hello， 所以接口2的请求参数中是有这个hello，<br>所以就会执行第一句world，<br>如果修改接口路由中的不是hello，就会执行error</p><p><img src="https://i.loli.net/2021/05/07/GV2YQEZpMA4shzj.png" alt="img"></p>]]></content>
    
    
    <summary type="html">Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。Vue为MVVM框架，MVVM是前端页面的分层开发思想，主要关注于 视图层 分离。也就是说：MVVM把前端的视图层，分为了三部分 Model, View,  ViewModel</summary>
    
    
    
    <category term="vue" scheme="https://chengling0824.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://chengling0824.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue cli脚手架</title>
    <link href="https://chengling0824.github.io/2021/04/12/Vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>https://chengling0824.github.io/2021/04/12/Vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/</id>
    <published>2021-04-12T01:47:05.000Z</published>
    <updated>2021-04-17T16:38:57.153Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p><a href="https://cli.vuejs.org/zh/">Vue CLI ：官方文档</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>全局安装<code>npm install -g @vue/cli</code>, 一次安装永久使用</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>一、使用 <code>vue ui</code> ,启动可视化面板创建项目</p><p>二、基于交互式命令创建项目</p><p><code>vue create hello-world</code>  (注意项目名不可以有大写)</p><p>输入命令后，会跳出几个选项让你回答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please pick a present:</span><br><span class="line"><span class="keyword">default</span> <span class="comment">//可以选默认的包含了基本的 Babel + ESLint 设置的 preset</span></span><br><span class="line">Manually select features <span class="comment">//手动配置，根据你需要用方向键选择（按 “空格键”选择/取消选择，A键全选/取消全选）对应功能</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">? Check the features needed <span class="keyword">for</span> your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">&gt;( ) Babel                           <span class="comment">//转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。                      </span></span><br><span class="line"> ( ) TypeScript<span class="comment">// TypeScript是一个JavaScript（后缀.js）的超集（后缀.ts）包含并扩展了 JavaScript 的语法，需要被编译输出为 JavaScript在浏览器运行，目前较少人再用</span></span><br><span class="line"> ( ) <span class="function">Progressive Web <span class="title">App</span> <span class="params">(PWA)</span> Support<span class="comment">// 渐进式Web应用程序</span></span></span><br><span class="line"><span class="function"> <span class="params">( )</span> Router                           <span class="comment">// vue-router（vue路由）</span></span></span><br><span class="line"><span class="function"> <span class="params">( )</span> Vuex                             <span class="comment">// vuex（vue的状态管理模式）</span></span></span><br><span class="line"> ( ) CSS Pre-processors               // CSS 预处理器（如：less、sass）</span><br><span class="line"> ( ) Linter / Formatter               <span class="comment">// 代码风格检查和格式化（如：ESlint）</span></span><br><span class="line"> ( ) Unit Testing                     <span class="comment">// 单元测试（unit tests）</span></span><br><span class="line"> ( ) E2E Testing                      <span class="comment">// e2e（end to end） 测试</span></span><br></pre></td></tr></table></figure><p>选择完后直接enter，然后会提示你选择对应功能的具体工具包，选择自己擅长或者使用广泛的（方便遇到问题时百度）</p><ul><li>是否使用<strong>history router</strong>：</li></ul><p>history：利用了 HTML5 History Interface 中新增的 pushState( ) 和 replaceState( ) 方法（需要特定浏览器支持）。单页客户端应用，history mode 需要后台配置支持（详细参见：<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90">https://router.vuejs.org/zh/guide/essentials/history-mode.html</a>）</p><ul><li><strong>css预处理器</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Check the features needed <span class="keyword">for</span> your project: Router, Vuex, CSS Pre-processors, Linter, Unit</span><br><span class="line"> Pick a CSS pre-<span class="built_in">processor</span> (PostCSS, Autoprefixer <span class="keyword">and</span> CSS Modules are supported by <span class="keyword">default</span>):</span><br><span class="line">&gt; SCSS/SASS  <span class="comment">//Sass安装需要Ruby环境，是在服务端处理的，SCSS 是 Sass3新语法（完全兼容 CSS3且继承Sass功能）</span></span><br><span class="line">  LESS       <span class="comment">//Less最终会通过编译处理输出css到浏览器，Less 既可以在客户端上运行，也可在服务端运行 (借助 Node.js)</span></span><br><span class="line">  Stylus     <span class="comment">//Stylus主要用来给Node项目进行CSS预处理支持，Stylus功能上更为强壮，和js联系更加紧密，可创建健壮的、动态的的CSS。</span></span><br></pre></td></tr></table></figure><ul><li><strong>ESLint</strong>：提供一个插件化的javascript代码检测工具</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Pick a linter / formatter config: (Use arrow keys)</span><br><span class="line">&gt; ESLint with error prevention only </span><br><span class="line">ESLint + Airbnb config</span><br><span class="line">ESLint + Standard config</span><br><span class="line">ESLint + Prettier <span class="comment">//使用较多</span></span><br></pre></td></tr></table></figure><ul><li><strong>何时检测</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">&gt;( ) Lint on save                    <span class="comment">// 保存就检测</span></span><br><span class="line"> ( ) Lint <span class="keyword">and</span> fix on commit          <span class="comment">// fix和commit时候检查</span></span><br></pre></td></tr></table></figure><ul><li><strong>单元测试</strong> ：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Pick a unit testing solution: (Use arrow keys)</span><br><span class="line">&gt; Mocha + Chai  <span class="comment">//mocha灵活,只提供简单的测试结构，如果需要其他功能需要添加其他库/插件完成。必须在全局环境中安装</span></span><br><span class="line">  Jest          <span class="comment">//安装配置简单，容易上手。内置Istanbul，可以查看到测试覆盖率，相较于Mocha:配置简洁、测试代码简洁、易于和babel集成、内置丰富的expect</span></span><br></pre></td></tr></table></figure><ul><li><strong>如何存放配置</strong> ：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Where <span class="keyword">do</span> you prefer placing config <span class="keyword">for</span> Babel, PostCSS, ESLint, etc.? (Use arrow keys)</span><br><span class="line">&gt; In dedicated config files <span class="comment">// 独立文件放置</span></span><br><span class="line">  In package.json <span class="comment">// 放package.json里</span></span><br></pre></td></tr></table></figure><ul><li><strong>是否保存本次配置</strong>（之后可以直接使用）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? Save <span class="keyword">this</span> as a preset <span class="keyword">for</span> future projects? (Y/n) <span class="comment">// y:记录本次配置，然后需要你起个名; n：不记录本次配置</span></span><br></pre></td></tr></table></figure><h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><p><code>npm run serve</code></p><h1 id="vue-cli的webpack配置分析"><a href="#vue-cli的webpack配置分析" class="headerlink" title="vue-cli的webpack配置分析"></a>vue-cli的webpack配置分析</h1><ul><li><p>从<code>package.json</code>可以看到开发和生产环境的入口。</p><img src="https://upload-images.jianshu.io/upload_images/10868449-255932a94e033291.png" alt="img"  /></li><li><p>可以看到dev中的设置，build/webpack.dev.conf.js，该文件是开发环境中webpack的配置入口。</p></li><li><p>在webpack.dev.conf.js中出现webpack.base.conf.js，这个文件是开发环境和生产环境，甚至测试环境，这些环境的公共webpack配置。可以说，这个文件相当重要。</p></li><li><p>还有config/index.js 、build/utils.js 、build/build.js等，具体请看这篇介绍：<br><a href="https://link.jianshu.com/?t=https://segmentfault.com/a/1190000008644830">https://segmentfault.com/a/1190000008644830</a></p></li></ul><h1 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h1><p>注意，自己的项目文件都需要放到 src 文件夹下。<br>在项目开发完成之后，可以输入 <code>npm run build</code> 来进行打包工作。</p><p>另：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.npm</span> 开启了npm run dev以后怎么退出或关闭？</span><br><span class="line">ctrl+c</span><br><span class="line"><span class="number">2</span><span class="selector-class">.--save-dev</span></span><br><span class="line">自动把模块和版本号添加到模块配置文件package<span class="selector-class">.json</span>中的依赖里devdependencies部分</span><br><span class="line"><span class="number">3</span>. --save-dev 与 --save 的区别</span><br><span class="line">--save     安装包信息将加入到dependencies（生产阶段的依赖）</span><br><span class="line">--save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它</span><br></pre></td></tr></table></figure><p>打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看。<br>项目上线时，只需要将 dist 文件夹放到服务器就行了。</p>]]></content>
    
    
    <summary type="html">安装 全局安装`npm install -g @vue/cli`, 一次安装永久使用 创建项目：一、使用 `vue ui` ,启动可视化面板创建项目 二、基于交互式命令创建项目</summary>
    
    
    
    <category term="vue" scheme="https://chengling0824.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://chengling0824.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>一起学习TypeScript(教程合集)</title>
    <link href="https://chengling0824.github.io/2021/04/09/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0TypeScript-%E6%95%99%E7%A8%8B%E5%90%88%E9%9B%86/"/>
    <id>https://chengling0824.github.io/2021/04/09/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0TypeScript-%E6%95%99%E7%A8%8B%E5%90%88%E9%9B%86/</id>
    <published>2021-04-09T02:01:32.000Z</published>
    <updated>2021-04-09T02:03:56.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一起学习TypeScript"><a href="#一起学习TypeScript" class="headerlink" title="一起学习TypeScript"></a>一起学习TypeScript</h1><blockquote><p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript。</p></blockquote><p><a href="https://www.typescriptlang.org/">TypeScript</a> 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p><h2 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h2><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#typescript-%E6%95%99%E7%A8%8B">TypeScript 教程</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9TypeScript">为什么选择 TypeScript</a></li><li><a href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">学习资源</a><ul><li><a href="https://github.com/xcatliu/typescript-tutorial">TypeScript 入门教程</a></li><li><a href="#%E8%BF%9B%E9%98%B6">进阶</a></li><li><a href="#%E5%AE%9E%E6%88%98">实战</a></li></ul></li></ul></li><li><a href="#typescript-starterboilerplate">TypeScript Starter/Boilerplate</a></li><li><a href="#typescript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">TypeScript 设计模式</a></li><li><a href="#typescript-%E8%A7%86%E9%A2%91">TypeScript 视频</a><ul><li><a href="#%E4%B8%AD%E6%96%87%E8%A7%86%E9%A2%91">中文视频</a></li><li><a href="#%E8%8B%B1%E6%96%87%E8%A7%86%E9%A2%91">英文视频</a></li></ul></li><li><a href="#typescript-%E9%97%AE%E7%AD%94">TypeScript 问答</a></li><li><a href="#typescript-%E4%B9%A6%E7%B1%8D">TypeScript 书籍</a><ul><li><a href="#%E4%B8%AD%E6%96%87%E4%B9%A6%E7%B1%8D">中文书籍</a></li><li><a href="#%E8%8B%B1%E6%96%87%E4%B9%A6%E7%B1%8D">英文书籍</a></li></ul></li><li><a href="#typescript-%E5%B7%A5%E5%85%B7%E5%BA%93%E6%A1%86%E6%9E%B6">TypeScript 工具/库/框架</a><ul><li><a href="#%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7">构建工具</a><ul><li><a href="#webpack">webpack</a></li><li><a href="#gulp">gulp</a></li><li><a href="#grunt">grunt</a></li><li><a href="#compiler">compiler</a></li><li><a href="#linter">linter</a></li></ul></li><li><a href="#ioc">Ioc</a></li><li><a href="#%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90">文档生成</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li><li><a href="#server">Server</a></li></ul></li><li><a href="#typescript-ide">TypeScript IDE</a><ul><li><a href="#offline">Offline</a><ul><li><a href="#ide%E6%8F%92%E4%BB%B6">IDE/插件</a></li></ul></li><li><a href="#online">Online</a><ul><li><a href="#playground">Playground</a></li><li><a href="#chrome-%E6%89%A9%E5%B1%95">Chrome 扩展</a></li></ul></li></ul></li><li><a href="#%E8%B4%A1%E7%8C%AE">贡献</a><ul><li><a href="#%E6%8C%87%E5%8D%97">指南</a></li></ul></li></ul><hr><h2 id="TypeScript-教程"><a href="#TypeScript-教程" class="headerlink" title="TypeScript 教程"></a>TypeScript 教程</h2><h3 id="为什么选择TypeScript"><a href="#为什么选择TypeScript" class="headerlink" title="为什么选择TypeScript"></a>为什么选择TypeScript</h3><ul><li><a href="https://juejin.im/post/59c46bc86fb9a00a4636f939">蚂蚁金服数据体验技术团队 - TypeScript体系调研报告</a></li><li><a href="https://zhuanlan.zhihu.com/p/21629069">Vilicvane - TypeScript 2.0 新特性一览</a></li><li><a href="https://zhuanlan.zhihu.com/p/24267683">Vilicvane - TypeScript 2.1 新特性一览</a></li><li><a href="https://zhuanlan.zhihu.com/p/25579011">Vilicvane - TypeScript 2.2 新特性一览</a></li><li><a href="https://zhuanlan.zhihu.com/p/27349475">Vilicvane - TypeScript 2.3 新特性一览</a></li><li><a href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript">Microsoft - TypeScript 2.4 新特性一览</a></li><li><a href="https://zhuanlan.zhihu.com/p/30760290">Vilicvane - TypeScript 2.5~2.6 新特性一览</a></li><li><a href="https://zhuanlan.zhihu.com/p/37374083">黄子毅 - 精读&lt;&lt;TypeScript2.0 - 2.9&gt;&gt;</a></li><li><a href="https://zhuanlan.zhihu.com/p/28494162">Linux中国 - 一篇缺失的 TypeScript 介绍</a></li><li><a href="http://www.jianshu.com/p/3c8c7713fa0e">单纯的土豆 - ES5, ES2015 和 TypeScript 的区别</a></li><li><a href="https://zhuanlan.zhihu.com/p/38526585">三七二十 - TypeScript 的好处都有啥？和 JavaScript 的区别在哪？</a></li><li><a href="https://www.jianshu.com/p/0dfbcd4a0757">Grain 先森 - 前端-TypeScript VS JavaScript 深度对比</a></li><li><a href="http://www.jianshu.com/p/27c026734b8d">贺贺v5 - Angular2、Ionic、TypeScript、es6的关系？</a></li><li><a href="http://www.jianshu.com/p/066a6017db1b">极客学院 - 使用 TypeScript 提高开发能力</a></li><li><a href="https://zhuanlan.zhihu.com/p/27695708">Hevin - 为什么 Reddit 选择了 TypeScript？</a></li><li><a href="https://segmentfault.com/a/1190000010892897">JiaXinYi - Angular: 我们为什么选择 TypeScript</a></li><li><a href="http://djcordhose.github.io/flow-vs-typescript/flow-typescript-2.html#/">Djcordhose - 对比 Flow 和 TypeScript</a></li><li><a href="https://github.com/neal1991/articles-translator/blob/master/%E9%87%87%E7%94%A8Flow%E4%BB%A5%E5%8F%8ATypeScript.md">Neal1991 - 采用 Flow 以及 TypeScript</a></li><li><a href="https://zhuanlan.zhihu.com/p/27593029">柳佳 - Flow vs. Typescript</a></li><li><a href="https://sdk.cn/news/6789">SDK.cn - Slack 的 TypeScript 之路</a></li><li><a href="https://segmentfault.com/a/1190000014414303">RDDcoding - 熟悉全栈TypeScript</a></li><li><a href="http://www.lxxyx.win/2017/07/23/2017/ts-accerlate/">Lxxyx - TypeScript - 不止稳，而且快</a></li></ul><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><ul><li><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/">Zhongsp - TypeScript Handbook (中文版)</a></li><li><a href="https://www.w3cschool.cn/typescript/">Bjcl - TypeScript 教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/32112508">Jason - 你所不知道的 Typescript 与 Redux 类型优化</a></li><li><a href="https://zhuanlan.zhihu.com/p/39620591">王亦斯 - 巧用 Typescript</a></li><li><a href="https://jkchao.cn/article/5bb9c63963a5d23d5ce3091b">三毛 - 巧用 TypeScript （一）</a></li><li><a href="https://jkchao.cn/article/5bde8fdf94307c57d4c8d37a">三毛 - 巧用 TypeScript （二）</a></li><li><a href="https://jkchao.cn/article/5befe57994307c57d4c8d383">三毛 - 巧用 TypeScript （三）</a></li><li><a href="https://jkchao.cn/article/5c162137e35fb85c4c7e1278">三毛 - 巧用 TypeScript （四）</a></li><li><a href="https://jkchao.cn/article/5c8a4d99e53a054fad647c15">三毛 - 巧用 TypeScript （五）</a></li><li><a href="https://zhuanlan.zhihu.com/p/38687656">Square - TypeScript 3.0 元组类型的用法和一些奇技淫巧</a></li><li><a href="https://zhuanlan.zhihu.com/p/38789971">Square - Typescript 类型高级技巧，和强约束 bind 的实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/38081852">腾讯NEXT学位 - 深入 TypeScript 的类型系统</a></li><li><a href="https://zhuanlan.zhihu.com/p/30360931">newraina - 手把手教写 TypeScript Transformer Plugin</a></li><li><a href="https://juejin.im/post/5bf7f1c0e51d455ed74f625c">EER - TypeScript 重构 Axios 经验分享</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/">三毛 - 深入理解 TypeScript</a></li></ul><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p><strong>Angular</strong></p><ul><li><a href="https://www.gitbook.com/book/yanxiaodi/ionic2-guide/details">Yanxiaodi - Ionic 2 With TypeScript</a></li><li><a href="https://juejin.im/entry/5811c2cba22b9d00639f69f5">Cacivy - Angular 2 + TypeScript 实现的 Cnode 社区</a></li></ul><p><strong>Vue</strong></p><ul><li><a href="https://segmentfault.com/a/1190000013676663">薯条真的好好吃哦 - almost最好的Vue + Typescript系列01 环境搭建篇</a></li><li><a href="https://segmentfault.com/a/1190000011474717">toBeTheLight - Vue 2.5中将迎来有关TypeScript的改进！</a></li><li><a href="https://segmentfault.com/a/1190000011853167">盘风 - Vue2.5+ Typescript 引入全面指南</a></li><li><a href="https://mp.weixin.qq.com/s/p2Uc9IV284MXbRHhV2Vf-g">腾讯Bugly - vuejs+ts+webpack2框架的项目实践</a></li><li><a href="https://segmentfault.com/a/1190000011520912">LinkFly - 从 JavaScript 到 TypeScript 6 - Vue 引入 TypeScript</a></li><li><a href="https://segmentfault.com/a/1190000012486378">SimonZhanglTer - 可能是最全的Vue-TypeScript教程(附实例代码和一键构建工具)</a></li><li><a href="https://segmentfault.com/a/1190000011878086">三命 - vue + typescript 进阶篇</a></li><li><a href="https://juejin.im/post/5b54886ce51d45198f5c75d7">qiangdada - TypeScript + 大型项目实战</a></li><li><a href="https://segmentfault.com/a/1190000013462418">距离 - Vue全家桶+TypeScript使用总结</a></li><li><a href="https://segmentfault.com/a/1190000014884801">海蓝2018 - vue全家桶+Typescript开发一款习惯养成APP</a></li><li><a href="https://juejin.im/entry/58d8d603b123db199f4639a3">Treri - 使用FIS3 和 TypeScript 实现 vue-hackernews-2.0</a></li><li><a href="https://juejin.im/post/5ba3d205e51d450e8477af33">🍼holyZhengs - 记录一次基于vue、typescript、pwa的项目由开发到部署</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTExNzYwNg==&mid=2247484478&idx=1&sn=a1222cc6d327fe80690b71e4398a27a2&chksm=fbb58ff7ccc206e12b5e2d57fb7cf84f8fe31dce3213e9b2c9ea00d5555873ddbb68ff2fde84&token=1712114111&lang=zh_CN&rd2werd=1#wechat_redirect">大转转FE - 原有vue项目接入typescript</a></li><li><a href="https://juejin.im/post/5bc2fd06e51d450e7903c783">MartinYin - 使用typescript+vue 编写电影信息小项目！</a></li><li><a href="https://jkchao.cn/article/5b3d3bbef9d34142a117b184">三毛 - 在 Vue 中使用 TypeScript 的一些思考（实践）</a></li></ul><p><strong>React</strong></p><ul><li><a href="https://juejin.im/post/5b715796e51d4566334ca28c">fi3ework - 基于 React + TypeScript 的网易云音乐</a></li><li><a href="https://juejin.im/post/595cc34ff265da6c3d6c262b">iKcamp - 翻译 | 开始使用 TypeScript 和 React</a></li><li><a href="https://segmentfault.com/a/1190000016163937">贾顺名 - TypeScript在react项目中的实践</a></li><li><a href="https://juejin.im/post/5bab4d59f265da0aec22629b">花生毛豆 - TypeScript 在 React 中使用总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/42141179">icepy - 复杂 React 应用中的TypeScript 3.0实践</a></li><li><a href="https://juejin.im/post/5a9c004a6fb9a028b92c9e91">蚂蚁金服数据体验技术团队 - TypeScript 实践</a></li><li><a href="https://juejin.im/post/5b07caf16fb9a07aa83f2977">蚂蚁金服数据体验技术团队 - TypeScript 2.8下的终极React组件模式</a></li></ul><p><strong>React Native</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/27029898">胡桓铭 - React Native 与 TypeScript 在企业开发中的实践</a></li></ul><p><strong>Wechat</strong></p><ul><li><a href="https://segmentfault.com/a/1190000008175944">Guyoung - 使用 TypeScript 开发微信小程序</a></li></ul><p><strong>Node.js</strong></p><ul><li><a href="https://www.jianshu.com/p/6aab86403dc1">MarxJiao - 使用webpack搭建基于typescript的node开发环境</a></li><li><a href="https://zhuanlan.zhihu.com/p/35334932">天猪 - 当 Egg 遇到 TypeScript，收获茶叶蛋一枚</a></li><li><a href="https://75team.com/post/thinkjs-3.0-with-typescript.html">奇舞团 - ThinkJS 3.0 如何实现对 TypeScript 的支持</a></li><li><a href="https://segmentfault.com/a/1190000015719697">贾顺名 - TypeScript在node项目中的实践</a></li><li><a href="https://mp.weixin.qq.com/s/agjjsO-47Qdd517wthadFg">贾顺名 - 使用 TS + Sequelize 实现更简洁的 CRUD</a></li><li><a href="https://juejin.im/post/5b89e47f51882542c062651f">YDJFE - 一次TypeScript, React, Node, MongoDB的模板式前后端分离开发实践</a></li></ul><hr><h2 id="TypeScript-设计模式"><a href="#TypeScript-设计模式" class="headerlink" title="TypeScript 设计模式"></a>TypeScript 设计模式</h2><ul><li><a href="https://juejin.im/post/59fa88ac5188255a6a0d5f31">蚂蚁金服数据体验技术团队 - Typescript玩转设计模式 之 创建型模式</a></li><li><a href="https://juejin.im/post/5a2d16325188252da0535d73">蚂蚁金服数据体验技术团队 - Typescript玩转设计模式 之 结构型模式（上）</a></li><li><a href="https://juejin.im/post/5a51da10f265da3e347b1483">蚂蚁金服数据体验技术团队 - Typescript玩转设计模式 之 结构型模式（下）</a></li><li><a href="https://juejin.im/post/5a6dd4dd51882573385ffa8e">蚂蚁金服数据体验技术团队 - Typescript玩转设计模式 之 对象行为型模式（上）</a></li><li><a href="https://juejin.im/post/5a77211b6fb9a0635774d61a">蚂蚁金服数据体验技术团队 -Typescript玩转设计模式 之 对象行为型模式（下）</a></li><li><a href="https://zhuanlan.zhihu.com/p/43283016">杜帅 - 浅析Typescript设计模式</a></li><li><a href="https://github.com/torokmark/design_patterns_in_typescript">torokmark - design_patterns_in_typescript</a></li></ul><hr><h2 id="TypeScript-书籍"><a href="#TypeScript-书籍" class="headerlink" title="TypeScript 书籍"></a>TypeScript 书籍</h2><h3 id="中文书籍"><a href="#中文书籍" class="headerlink" title="中文书籍"></a>中文书籍</h3><ul><li><a href="https://item.jd.com/12001593.html">Learning TypeScript (中文版)</a></li><li><a href="https://item.jd.com/11948831.html">迈向 Angular 2: 基于 TypeScript 的高性能 SPA 框架</a></li></ul><h3 id="英文书籍"><a href="#英文书籍" class="headerlink" title="英文书籍"></a>英文书籍</h3><ul><li><a href="https://www.amazon.cn/dp/B00OUJL6P0">TypeScript Essentials</a></li><li><a href="https://www.amazon.cn/dp/B00WMLHQFC">Mastering TypeScript</a></li><li><a href="https://www.amazon.cn/dp/B01DPR2EQC/">Mastering TypeScript - Second Edition</a></li><li><a href="https://www.amazon.cn/dp/B0151N0G7W/">Learning TypeScript</a></li><li><a href="https://www.amazon.cn/dp/B078PQ6MF4/">Learning TypeScript 2.x</a></li><li><a href="https://www.amazon.cn/dp/B075V9K4CC/">TypeScript 2.x By Example</a></li><li><a href="https://www.amazon.cn/dp/B0753J1W3Z">TypeScript 2.x for Angular Developers</a></li><li><a href="https://www.amazon.cn/dp/1617293121">Angular 2 Development with TypeScript </a></li><li><a href="https://www.amazon.cn/dp/B01MZ2PTHY/">TypeScript: Modern JavaScript Development</a></li><li><a href="https://www.amazon.cn/dp/B01CUI0JW8">TypeScript Blueprints</a></li><li><a href="https://www.amazon.cn/dp/1484232488">Pro TypeScript</a></li><li><a href="https://www.amazon.cn/dp/B01BSTEDI6/">TypeScript Design Patterns</a></li><li><a href="https://www.amazon.cn/dp/B071VVFD4D/">TypeScript High Performance</a></li><li><a href="https://www.amazon.cn/dp/B078N3XCVG/">TypeScript Microservices</a></li></ul><hr><h2 id="TypeScript-工具-库-框架"><a href="#TypeScript-工具-库-框架" class="headerlink" title="TypeScript 工具/库/框架"></a>TypeScript 工具/库/框架</h2><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><ul><li><a href="https://github.com/s-panferov/awesome-typescript-loader">s-panferov - awesome-typescript-loader</a></li><li><a href="https://github.com/TypeStrong/ts-loader">TypeStrong - ts-loader</a></li></ul><h4 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h4><ul><li><a href="https://github.com/ivogabe/gulp-typescript">ivogabe - gulp-typescript</a></li></ul><h4 id="grunt"><a href="#grunt" class="headerlink" title="grunt"></a>grunt</h4><ul><li><a href="https://github.com/TypeStrong/grunt-ts">TypeStrong - grunt-ts</a></li></ul><h4 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h4><ul><li><a href="https://github.com/TypeStrong/ts-node">TypeStrong - ts-node</a></li><li><a href="https://github.com/AssemblyScript/assemblyscript">AssemblyScript - assemblyscript</a></li><li><a href="https://github.com/bcherny/json-schema-to-typescript">bcherny - json-schema-to-typescript</a></li><li><a href="https://github.com/YousefED/typescript-json-schema">YousefED - typescript-json-schema</a></li></ul><h4 id="linter"><a href="#linter" class="headerlink" title="linter"></a>linter</h4><ul><li><a href="https://github.com/palantir/tslint">palantir - tslint</a></li></ul><h3 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h3><ul><li><a href="https://github.com/inversify/InversifyJS">Inversify - InversifyJS</a></li><li><a href="https://github.com/inversify/inversify-express-example">Inversify - inversify-express-example</a></li></ul><h3 id="文档生成"><a href="#文档生成" class="headerlink" title="文档生成"></a>文档生成</h3><ul><li><a href="https://github.com/TypeStrong/typedoc">TypeStrong - typedoc</a></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><a href="https://github.com/dcodeIO/protobuf.js">dcodeIO - protobuf.js</a></li><li><a href="https://github.com/basarat/typescript-collections">basarat - typescript-collections</a></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><a href="https://github.com/typeorm/typeorm">Typeorm - typeorm</a></li><li><a href="https://github.com/RobinBuschmann/sequelize-typescript">RobinBuschmann - sequelize-typescript</a></li></ul><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><ul><li><a href="https://eggjs.org/">Alibaba - egg.js</a></li><li><a href="https://github.com/thinkjs/thinkjs">welefen - thinkjs</a></li><li><a href="https://github.com/nestjs/nest">kamilmysliwiec - nest</a></li></ul><hr><h2 id="TypeScript-IDE"><a href="#TypeScript-IDE" class="headerlink" title="TypeScript IDE"></a>TypeScript IDE</h2><h3 id="Offline"><a href="#Offline" class="headerlink" title="Offline"></a>Offline</h3><h4 id="IDE-插件"><a href="#IDE-插件" class="headerlink" title="IDE/插件"></a>IDE/插件</h4><ul><li><a href="https://visualstudio.microsoft.com/zh-hans/vs/community/">Visual Studio Community</a></li><li><a href="https://www.visualstudio.com/en-us/products/code-vs.aspx">Visual Studio Code</a></li><li><a href="https://www.jetbrains.com/webstorm/">WebStorm</a></li><li><a href="https://www.jetbrains.com/phpstorm/download/">PhpStorm</a></li><li><a href="https://github.com/Microsoft/TypeScript-Sublime-Plugin">TypeScript Sublime Plugin</a></li><li><a href="https://github.com/TypeStrong/atom-typescript">Atom TypeScript</a></li><li><a href="https://github.com/ananthakumaran/tide">TypeScript Interactive Development Environment for Emacs</a></li><li><a href="http://typecsdev.com/">TypeScript IDE for Eclipse</a></li><li><a href="https://github.com/leafgarland/typescript-vim">TypeScript Syntax for VIM</a></li></ul><h3 id="Online"><a href="#Online" class="headerlink" title="Online"></a>Online</h3><h4 id="Playground"><a href="#Playground" class="headerlink" title="Playground"></a>Playground</h4><ul><li><a href="http://www.typescriptlang.org/Playground/">TypeScript official Playground</a></li><li><a href="https://stackblitz.com/">Stackblitz</a></li><li><a href="http://jsbin.com/?js">JS Bin</a></li><li><a href="http://codepen.io/">Codepen</a></li><li><a href="http://drake7707.github.io/Typescript-Editor/">TypeScript Editor</a></li><li><a href="http://niutech.github.io/typescript-interpret/">TypeScript Interpret - Terminal Emulator</a></li><li><a href="https://agentcooper.github.io/typescript-play/">TypeScript Play</a></li></ul><h4 id="Chrome-扩展"><a href="#Chrome-扩展" class="headerlink" title="Chrome 扩展"></a>Chrome 扩展</h4><ul><li><a href="https://github.com/OctoLinker/browser-extension">OctoLinker</a></li></ul>]]></content>
    
    
    <summary type="html">TypeScript is a typed superset of JavaScript that compiles to plain JavaScript。[TypeScript](https://www.typescriptlang.org/) 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程...</summary>
    
    
    
    <category term="TypeScript" scheme="https://chengling0824.github.io/categories/TypeScript/"/>
    
    
    <category term="TypeScript" scheme="https://chengling0824.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>css浮动</title>
    <link href="https://chengling0824.github.io/2021/04/01/css%E6%B5%AE%E5%8A%A8/"/>
    <id>https://chengling0824.github.io/2021/04/01/css%E6%B5%AE%E5%8A%A8/</id>
    <published>2021-04-01T06:51:24.000Z</published>
    <updated>2021-04-12T03:33:05.605Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>浮动的定义：使元素脱离文档流，按照指定方向（左右）发生移动，遇到父级边界或者相邻的浮动元素停了下来。</p></blockquote><h1 id="浮动中将会遇到的问题"><a href="#浮动中将会遇到的问题" class="headerlink" title="浮动中将会遇到的问题"></a>浮动中将会遇到的问题</h1><h2 id="第一种情况-导致的各种布局混乱问题"><a href="#第一种情况-导致的各种布局混乱问题" class="headerlink" title="第一种情况 导致的各种布局混乱问题"></a>第一种情况 导致的各种布局混乱问题</h2><blockquote><p>（浮动元素不占位置导致的布局变化）</p></blockquote><h2 id="第二种情况-浮动的元素只影响他后面的元素-根据层叠顺序推算"><a href="#第二种情况-浮动的元素只影响他后面的元素-根据层叠顺序推算" class="headerlink" title="第二种情况 浮动的元素只影响他后面的元素    根据层叠顺序推算"></a>第二种情况 浮动的元素只影响他后面的元素    根据层叠顺序推算</h2><h2 id="第三种情况-导致的各种掉盒子问题"><a href="#第三种情况-导致的各种掉盒子问题" class="headerlink" title="第三种情况 导致的各种掉盒子问题"></a>第三种情况 导致的各种掉盒子问题</h2><p>如果父级宽度太窄，无法容纳所有元素，无法容纳的元素会掉下去，之后还是会执行浮动，向左/右直到遇到边框就会停下来！</p><h2 id="第四种情况-导致的各种被卡住问题"><a href="#第四种情况-导致的各种被卡住问题" class="headerlink" title="第四种情况 导致的各种被卡住问题"></a>第四种情况 导致的各种被卡住问题</h2><blockquote><p>浮动的元素高度不同，并且外面盒子宽度不够的情况下，往下掉的过程中可能会被卡住（掉出来后盒子仍向左/右执行浮动）</p></blockquote><h1 id="float元素的特性"><a href="#float元素的特性" class="headerlink" title="float元素的特性"></a>float元素的特性</h1><ul><li><p>设置了浮动的元素，变成浮动元素，具备浮动元素特性</p></li><li><p>都支持横排显示 </p></li><li><p>都支持宽高  </p></li><li><p>不给宽度的时候默认内容撑开宽高  </p></li><li><p>支持margin padding  </p></li><li><p>不支持margin:auto;  </p></li><li><p>浮动脱离文档流  </p></li><li><p>浮动提升层级半级 概念性理解，其实和层级没关系，只有定位有层级</p></li></ul><h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><h2 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h2><blockquote><p>浮动元素不占位置，由于不占位置导致父级的塌陷影响布局 （内容为0高度，父级高度由内容撑开的时候，也为0）</p></blockquote><h2 id="清除浮动的原则（清除浮动乃是清除浮动给父级带来的影响）"><a href="#清除浮动的原则（清除浮动乃是清除浮动给父级带来的影响）" class="headerlink" title="清除浮动的原则（清除浮动乃是清除浮动给父级带来的影响）"></a>清除浮动的原则（清除浮动乃是清除浮动给父级带来的影响）</h2><p>1.浮动元素本身不能清除浮动 比如div 设置了float 不能直接给div 运用clear来清除浮动   </p><p>2.哪里浮动，哪里给父元素清除！即浮动之后要立马解决这里由于浮动带来的影响！ 以免对后面的布局造成影响！</p><h2 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h2><h3 id="子元素方式：添加空标签"><a href="#子元素方式：添加空标签" class="headerlink" title="子元素方式：添加空标签"></a>子元素方式：添加空标签</h3><blockquote><p>在需要清除浮动的元素前面添加一个空的div</p><p>浮动元素本身不能清除浮动</p></blockquote><p><code>&lt;div style=&#39;clear:both;&#39;&gt;&lt;/div&gt;</code></p><h3 id="给父级用的方法"><a href="#给父级用的方法" class="headerlink" title="给父级用的方法"></a>给父级用的方法</h3><ol><li><p>给父元素添加高度  缺点是扩展性不好，一般都是内容撑开高度  </p></li><li><p>给父级inline­block  缺点是中间会解析空格   </p></li><li><p>overflow:hidden;  需要溢出隐藏的时候你就写，这样就不用写清楚浮动的样了   </p></li></ol><blockquote><p>在父元素上设置overflow这个属性，如果父元素的这个属性设置为auto或者是hidden，父元素就会扩展包含浮动</p></blockquote><ol start="4"><li>after伪类</li></ol><blockquote><p>利用伪类元素来清除有浮动的标签，也就定义一个公共的类clearfix，给这个类添加css属性，在里面进行清除浮动的操作。只要哪里需要清除浮动，就在哪里添加一个清除浮动的类</p></blockquote><blockquote><p>这种方式这样理解，就是利用伪类元素，也就是在有浮动的标签前面添加一个块级元素，来达到效果。</p><p><code>.clearfix:after&#123;content:&#39;&#39;;display:block;clear:both;&#125; </code></p></blockquote><blockquote><p>解决低版本ie的兼容性问题 :</p><p><code>.clearfix&#123;zoom：1；&#125; </code></p></blockquote>]]></content>
    
    
    <summary type="html">浮动的定义：使元素脱离文档流，按照指定方向（左右）发生移动，遇到父级边界或者相邻的浮动元素停了下来。 浮动中将会遇到的问题：第一种情况 导致的各种布局混乱问题  （浮动元素不占位置导致的布局变化）第二种情况 浮动的元素只影响他后面的元素   根据层叠顺序推算  第三种情况 导致的各种掉盒子问题...</summary>
    
    
    
    <category term="css" scheme="https://chengling0824.github.io/categories/css/"/>
    
    
    <category term="css" scheme="https://chengling0824.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>git基本操作</title>
    <link href="https://chengling0824.github.io/2021/04/01/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://chengling0824.github.io/2021/04/01/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-04-01T06:51:24.000Z</published>
    <updated>2021-04-12T03:32:49.237Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h1><h2 id="git的基本操作逻辑"><a href="#git的基本操作逻辑" class="headerlink" title="git的基本操作逻辑"></a>git的基本操作逻辑</h2><p><img src="https://pic4.zhimg.com/80/v2-aab55876b59f599900388a43db9ec69f_720w.jpg"></p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><ol><li>克隆版本库 git clone</li><li>获取更新，查看其他人的进程 git feach</li><li>取回更新，与本地合并 git pull</li><li>推送本地代码到远程主机 git push</li></ol>]]></content>
    
    
    <summary type="html">git的基本操作逻辑 常用指令：1. 克隆版本库 git clone 2. 获取更新，查看其他人的进程 git feach 3. 取回更新，与本地合并 git pull 4. 推送本地代码到远程主机 git push</summary>
    
    
    
    
    <category term="git" scheme="https://chengling0824.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>设置hexo首页只显示部分摘要（不显示全文）</title>
    <link href="https://chengling0824.github.io/2021/04/01/hexo%E6%A0%B7%E5%BC%8F%E8%B0%83%E6%95%B4%E8%AE%B0%E5%BD%95/"/>
    <id>https://chengling0824.github.io/2021/04/01/hexo%E6%A0%B7%E5%BC%8F%E8%B0%83%E6%95%B4%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-01T06:51:24.000Z</published>
    <updated>2021-04-09T01:57:53.892Z</updated>
    
    <content type="html"><![CDATA[<p>首先，修改配置</p><p>首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>然后，有两种方法：</p><p>方法一：写概述</p><p>在文章的<code>front-matter</code>中添加<code>description</code>，其中description中的内容就会被显示在首页上，其余一律不显示。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>方法二：文章截断</p><p>在需要截断的地方加入：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。<br>例如本文会显示到<code>修改配置</code>上面。</p>]]></content>
    
    
    <summary type="html">首先，需要先修改配置 首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)  然后，有两种方法：方法一：写概述 在文章的`front-matter`中添加`description`，其中description中的内容就会被显示在首页上，其余一律不显示。</summary>
    
    
    
    <category term="hexo—theme-next" scheme="https://chengling0824.github.io/categories/hexo%E2%80%94theme-next/"/>
    
    
    <category term="hexo" scheme="https://chengling0824.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Angular,React,Vue三大框架的比较</title>
    <link href="https://chengling0824.github.io/2021/04/01/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://chengling0824.github.io/2021/04/01/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2021-04-01T06:51:24.000Z</published>
    <updated>2021-04-12T03:33:20.489Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Angular-React-Vue三大框架的比较"><a href="#Angular-React-Vue三大框架的比较" class="headerlink" title="Angular,React,Vue三大框架的比较"></a>Angular,React,Vue三大框架的比较</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Angular是基于 TypeScript 的 Javascript 框架。</p><p>它是三大框架里最早针对页面性能问题提出的优化探索，并在2010年由Google对外发布，react、vue后面相继出现。然而Angular由于最早开始，那时候移动端还没有兴起，一开始定位的Web端有些不适应后来的移动端趋势，导致后面有个大的版本迭代。Angular团队在保持<strong>性能优化</strong>的核心方案的同时，适应<strong>移动端化、组件化</strong>的大热潮流，2016年推出了Angular2。并且官方团队在2018年将AngularJS宣布将进行LTS长期维护时间，以后将不再提供支持和更新。虽然目前很多团队的应用还是基于AngularJS，官方也建议尽快迁移。</p><p>React被描述为 “用于构建用户界面的 JavaScript 库”。</p><p>由Facebook在2013年正式对外发布，并一直由Facebook团队负责维护和推广。在 Chris Cordle 这篇文章的统计中，React 在 Facebook 上的使用远远多于 Angular 在 Google 上的使用。React 还被 Airbnb，Uber，Netflix，Twitter，Pinterest，Reddit，Udemy，Wix，Paypal，Imgur，Feedly，Stripe，Tumblr，Walmart 等使用（根据 Facebook, stackshare 和 libscore.com 提供的数据）。</p><p>Vue是近年国内发展最为迅速的 JS 框架。<br><img src="https://user-gold-cdn.xitu.io/2019/6/30/16ba79460127cd31?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br>这里可以看出，在国内，Vue的新潮不是空穴来风，它的热搜量还是稳居第一并继续持续提升的趋势。React, Angular都相对平缓。</p><p>但在国外，react仍占大头，Google趋势如下 :<br><img src="https://user-gold-cdn.xitu.io/2019/6/30/16ba78948101c826?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="Vue与AngularJS的区别"><a href="#Vue与AngularJS的区别" class="headerlink" title="Vue与AngularJS的区别"></a>Vue与AngularJS的区别</h2><p>相同点： 都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。<br>不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。</p><h2 id="Vue与React的区别"><a href="#Vue与React的区别" class="headerlink" title="Vue与React的区别"></a>Vue与React的区别</h2><p>相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。<br>不同点：React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。</p><h2 id="一点预测"><a href="#一点预测" class="headerlink" title="一点预测"></a>一点预测</h2><ol><li><p>从市场份额来看，React目前依旧占大额，但以后说不好，毕竟有个BSD license的问题争论。（很多公司和个人都已经迁移，因为目前Facebook旗下很多开源项目还都是BSD, 不确定哪天Facebook又把React切换回BSD。） Angular的趋势平缓，且有Google团队的支持，应该以后依旧会保持着现有的状态。Vue新贵虽然目前市场份额不大，但是发展趋势很迅猛，且跟多家大平台合作，在国内的资讯、媒体、社区都很活跃，所以发展前景还是可观的。</p></li><li><p>从社区支持来看，前面已经说过，Facebook支持着React，而Google支持着Angular，因此这两种框架的增长是毋庸置疑的。它们能够持续得到更新与发布，在碰到迁移时也有着很好的维护与支持。<br>React和Angular的开发人员都声称：升级不是问题，他们会每六个月发布一次主要更新。另外，由于Angular是一个完备的框架，而React是一组更独立、更快捷、且不断改进的库，因此React比Angular更灵活。不过，您也必须关注那些可能不再被支持或维护的小模块。而Vue这方面更缺失，没有一个明确的长远版本规划的路线图。</p></li><li><p>从框架、库角度来说，Angular是一个完备的框架，您不必查看各种库、路由方案和其具体结构，就能快速地开始构建。虽然Angualr4系列之后也在逐步减重，但不得不说，相比较React和Vue相对来说，还是厚重一些。React可以集成很多库来无缝连接搭建应用，但也因此导致React出错率和依赖性都偏高一些。Vue则是平衡了内部依赖和灵活性这块儿，所以相对来说轻而方便使用。</p></li><li><p>从学习曲线来看，Angular和React都有自己的一套，尤其Angular还有依赖注入的层次结构概念，很多都自己集成了，学习成本偏高。从这点来说，Vue的门槛真的很低。难怪现在很多公司偏向Vue, 人力成本低。</p></li></ol><p>随着微应用和微服务的兴起，React和Vue的灵活性更适合开发。Angular更偏单页应用。但Angular是最早拥抱typescript的(在npm2018年的调研中，编译js方法里以46%的占比一跃成为第二，紧跟Babel之后)，也是最早将RxJS思想贯彻到底的框架。</p>]]></content>
    
    
    <summary type="html">背景介绍：Angular是基于 TypeScript 的 Javascript 框架。它是三大框架里最早针对页面性能问题提出的优化探索，并在2010年由Google对外发布，react、vue后面相继出现。然而Angular由于最早开始，那时候移动端还没有兴起，一开始定位的Web端有些不适应后来的移动端趋势，导致后面有个大的版本迭代。Angular团队在保持**性能优化**的核心方案的同时，适应**移动端化、组件化**的大热潮流</summary>
    
    
    
    
    <category term="前端框架" scheme="https://chengling0824.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>2020 前端技术发展回顾</title>
    <link href="https://chengling0824.github.io/2021/04/01/2020-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E5%9B%9E%E9%A1%BE/"/>
    <id>https://chengling0824.github.io/2021/04/01/2020-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E5%9B%9E%E9%A1%BE/</id>
    <published>2021-04-01T06:45:52.000Z</published>
    <updated>2021-04-17T16:40:21.994Z</updated>
    
    <content type="html"><![CDATA[<p>2020 前端技术发展回顾：</p><p><a href="https://zhuanlan.zhihu.com/p/343552059?utm_source=wechat_timeline&amp;utm_medium=social&amp;utm_oi=42082701934592">https://zhuanlan.zhihu.com/p/343552059?utm_source=wechat_timeline&amp;utm_medium=social&amp;utm_oi=42082701934592</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2020 前端技术发展回顾：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/343552059?utm_source=wechat_timeline&amp;amp;utm_medium=social&amp;amp;utm_oi=4208270</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>this的指向问题</title>
    <link href="https://chengling0824.github.io/2021/03/24/JavaScript%E4%B9%8Bthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
    <id>https://chengling0824.github.io/2021/03/24/JavaScript%E4%B9%8Bthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-24T04:08:02.000Z</published>
    <updated>2021-04-12T03:32:29.906Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h1><blockquote><p>this是一个对象，但是我们不同的操作 this指向的对象是不相同的。</p></blockquote><h2 id="三种-this指向情况："><a href="#三种-this指向情况：" class="headerlink" title="三种 this指向情况："></a>三种 this指向情况：</h2><ol><li><p>对象调用，this 指向该对象（前边谁调用 this 就指向谁）</p></li><li><p>直接调用的函数，this 指向的是全局 window 对象</p></li><li><p>通过 new 的方式，this 永远被绑定在新创建的对象上，任何方式都改变不了 this 的指向</p></li></ol><blockquote><p>new的过程，其实在内部创建了一个空对象，然后将构造函数传入的参数和属性挂在了这个空对象上，然后返回了这个对象。</p></blockquote><h2 id="扩展：箭头函数的-this-指向谁？"><a href="#扩展：箭头函数的-this-指向谁？" class="headerlink" title="扩展：箭头函数的 this 指向谁？"></a>扩展：箭头函数的 this 指向谁？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D;&#123;</span><br><span class="line">    a:()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行程序，控制台输出：</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6758e10fbf72e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><blockquote><p>我们可以得出结论，this在箭头函数中失效了，因为这是由于箭头函数没有单独的 this值。</p><p>箭头函数的 this与声明所在的上下文相同。</p><p>也就是说调用箭头函数的时候，不会隐式的调用 this参数，而是从定义时的函数继承上下文。</p></blockquote><h1 id="如何改变-this-的值？"><a href="#如何改变-this-的值？" class="headerlink" title="如何改变 this 的值？"></a>如何改变 this 的值？</h1><ol><li><p>call 方法</p></li><li><p>apply 方法</p></li><li><p>bind 方法</p></li></ol>]]></content>
    
    
    <summary type="html">this是一个对象，但是我们不同的操作 this指向的对象是不相同的。 三种 this指向情况： 1. 对象调用，this 指向该对象（前边谁调用 this 就指向谁） 2. 直接调用的函数，this 指向的是全局 window 对象 3. 通过 new 的方式，this 永远被绑定在新创建的对象上，任何方式都改变不了 this 的指向...</summary>
    
    
    
    <category term="javascript" scheme="https://chengling0824.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://chengling0824.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>markdown常见指令</title>
    <link href="https://chengling0824.github.io/2021/03/24/markdown%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/"/>
    <id>https://chengling0824.github.io/2021/03/24/markdown%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/</id>
    <published>2021-03-24T04:08:02.000Z</published>
    <updated>2021-04-09T01:57:48.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><p>   · 标题通过 <code>#</code> 的个数来进行区分，Mardown总共支持6级标题。</p><span id="more"></span><h2 id="字体设置："><a href="#字体设置：" class="headerlink" title="字体设置："></a>字体设置：</h2><p>   · <strong>粗体：</strong><br>        字符串前后均加上 <code>**</code></p><p>   · <em>斜体</em><br>        字符串前后均加上 <code>*</code></p><p>   · <del>删除线</del><br>        字符串前后各加 <code>~~</code></p><p>   · 标记<br>        字体前后加上 ` (Esc下方的那个键)     </p><h2 id="区块引用："><a href="#区块引用：" class="headerlink" title="区块引用："></a>区块引用：</h2><blockquote><p>在使用的地方引用 <code>&gt;</code> (后面文本加空格)</p></blockquote><h2 id="首行缩进或空格"><a href="#首行缩进或空格" class="headerlink" title="首行缩进或空格"></a>首行缩进或空格</h2><p>   &nbsp; <code>&amp;nbsp;</code></p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>   · 连续多个（- 或 * 或 _）</p><hr><hr><h2 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h2><p>   图片<br>       <code>![]() : [图片名称] (图片网络地址)</code></p><p>   链接<br>       <code>[]() ： [链接名称(可自定义)] (链接地址)</code></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>   · 使用（<code>```  代码  ```</code>）</p><h2 id="网址自动转换"><a href="#网址自动转换" class="headerlink" title="网址自动转换"></a>网址自动转换</h2><p>   · 使用<code>&lt;&gt;</code>就会自动把它转成链接</p>]]></content>
    
    
    <summary type="html">标题： 标题通过 `#` 的个数来进行区分，Mardown总共支持6级标题。  字体设置：粗体：字符串前后均加上 `**`  斜体：字符串前后均加上 `*`   删除线：字符串前后各加 `~~`   标记：字体前后加上 ` (Esc下方的那个键)</summary>
    
    
    
    
    <category term="markdown" scheme="https://chengling0824.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>vue路由的实现与钩子函数</title>
    <link href="https://chengling0824.github.io/2021/03/24/vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0/"/>
    <id>https://chengling0824.github.io/2021/03/24/vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-03-24T04:08:02.000Z</published>
    <updated>2021-04-12T03:32:20.380Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Vue的路由实现：hash模式-和-history模式"><a href="#Vue的路由实现：hash模式-和-history模式" class="headerlink" title="Vue的路由实现：hash模式 和 history模式"></a>Vue的路由实现：hash模式 和 history模式</h1><p>通常 SPA 中前端路由有2种实现方式：</p><blockquote><p>window.history<br>location.hash</p></blockquote><p>下面就来介绍下这两种方式具体怎么实现的</p><h2 id="一-history"><a href="#一-history" class="headerlink" title="一. history"></a>一. history</h2><h3 id="1-history基本介绍"><a href="#1-history基本介绍" class="headerlink" title="1.history基本介绍"></a>1.history基本介绍</h3><blockquote><p> window.history 对象包含浏览器的历史，window.history 对象在编写时可不使用 window 这个前缀。history是实现SPA前端路由是一种主流方法，它有几个原始方法：</p><p>history.back() - 与在浏览器点击后退按钮相同<br>history.forward() - 与在浏览器中点击按钮向前相同<br>history.go(n) - 接受一个整数作为参数，移动到该整数指定的页面，比如go(1)相当于forward()，go(-1)相当于back()，go(0)相当于刷新当前页面<br>如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是静默失败</p></blockquote><p>history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。<br>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="http://www.xxx.com/items/id%E3%80%82">www.xxx.com/items/id。</a> 后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p><h3 id="2-history-pushState"><a href="#2-history-pushState" class="headerlink" title="2.history.pushState"></a>2.history.pushState</h3><p>pushState(stateObj, title, url) 方法向历史栈中写入数据，其第一个参数是要写入的数据对象（不大于640kB)，第二个参数是页面的 title, 第三个参数是 url (相对路径)。</p><p>stateObj ：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。</p><p>title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。</p><p>url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</p><p>关于pushState，有几个值得注意的地方：</p><p>pushState方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应,只有当触发前进后退等事件（back()和forward()等）时浏览器才会刷新</p><p>这里的 url 是受到同源策略限制的，防止恶意脚本模仿其他网站 url 用来欺骗用户，所以当违背同源策略时将会报错</p><h3 id="3-history-replaceState"><a href="#3-history-replaceState" class="headerlink" title="3.history.replaceState"></a>3.history.replaceState</h3><p>replaceState(stateObj, title, url) 和pushState的区别就在于它不是写入而是替换修改浏览历史中当前纪录，其余和 pushState一模一样</p><h3 id="4-popstate事件"><a href="#4-popstate事件" class="headerlink" title="4.popstate事件"></a>4.popstate事件</h3><p>定义：每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。</p><p>注意：仅仅调用pushState方法或replaceState方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用JavaScript调用back、forward、go方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p><p>用法：使用的时候，可以为popstate事件指定回调函数。这个回调函数的参数是一个event事件对象，它的state属性指向pushState和replaceState方法为当前URL所提供的状态对象（即这两个方法的第一个参数）。</p><h3 id="5-history实现spa前端路由代码"><a href="#5-history实现spa前端路由代码" class="headerlink" title="5.history实现spa前端路由代码"></a>5.history实现spa前端路由代码</h3><p><a class="api a">a.html</a><br><a class="api b">b.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册路由</span><br><span class="line">   document.querySelectorAll(&#39;.api&#39;).forEach(item &#x3D;&gt; &#123;</span><br><span class="line">     item.addEventListener(&#39;click&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">       e.preventDefault();</span><br><span class="line">       let link &#x3D; item.textContent;</span><br><span class="line">       if (!!(window.history &amp;&amp; history.pushState)) &#123;</span><br><span class="line">         &#x2F;&#x2F; 支持History API</span><br><span class="line">         window.history.pushState(&#123;name: &#39;api&#39;&#125;, link, link);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 不支持,可使用一些Polyfill库来实现</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, false)</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><pre><code>// 监听路由window.addEventListener(&#39;popstate&#39;, e =&gt; &#123;  console.log(&#123;    location: location.href,    state: e.state  &#125;)&#125;, false)</code></pre><p>复制代码<br>popstate监听函数里打印的e.state便是history.pushState()里传入的第一个参数，在这里即为{name: ‘api’}</p><h2 id="二-Hash"><a href="#二-Hash" class="headerlink" title="二. Hash"></a>二. Hash</h2><h3 id="1-Hash基本介绍"><a href="#1-Hash基本介绍" class="headerlink" title="1.Hash基本介绍"></a>1.Hash基本介绍</h3><blockquote><p>在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；<br>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。<br>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.xxx.com,因此对于后端来说,即使没有做到对路由的全覆盖,也不会返回/">www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回</a> 404 错误。</p></blockquote><p>window 对象中有一个事件是 onhashchange，以下几种情况都会触发这个事件：</p><p>直接更改浏览器地址，在最后面增加或改变#hash；<br>通过改变location.href或location.hash的值；<br>通过触发点击带锚点的链接；<br>浏览器前进后退可能导致hash的变化，前提是两个网页地址中的hash值不同。</p><h3 id="2-Hash实现spa前端路由代码"><a href="#2-Hash实现spa前端路由代码" class="headerlink" title="2.Hash实现spa前端路由代码"></a>2.Hash实现spa前端路由代码</h3><h1 id="vue路由的钩子函数"><a href="#vue路由的钩子函数" class="headerlink" title="vue路由的钩子函数"></a>vue路由的钩子函数</h1><p>首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。</p><ul><li>beforeEach主要有3个参数to，from，next：</li><li>to：route即将进入的目标路由对象，</li><li>from：route当前导航正要离开的路由</li><li>next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。</li></ul>]]></content>
    
    
    <summary type="html">通常 SPA 中前端路由有2种实现方式： window.history ，location.hash。下面就来介绍下这两种方式具体怎么实现的：一.history 1.history基本介绍 window.history 对象包含浏览器的历史，window.history 对象在编写时可不使用 window 这个前缀。history是实现SPA前端路由是一种主流方法，它有几个原始方法：</summary>
    
    
    
    <category term="vue" scheme="https://chengling0824.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://chengling0824.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://chengling0824.github.io/2021/03/24/hexo%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://chengling0824.github.io/2021/03/24/hexo%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2021-03-24T04:04:19.812Z</published>
    <updated>2021-04-01T06:39:58.051Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
