<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>chenry&#39;s sky</title>
  
  
  <link href="https://chengling0824.github.io/atom.xml" rel="self"/>
  
  <link href="https://chengling0824.github.io/"/>
  <updated>2021-04-12T03:35:22.740Z</updated>
  <id>https://chengling0824.github.io/</id>
  
  <author>
    <name>程羚</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue cli脚手架</title>
    <link href="https://chengling0824.github.io/2021/04/12/Vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>https://chengling0824.github.io/2021/04/12/Vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6/</id>
    <published>2021-04-12T01:47:05.000Z</published>
    <updated>2021-04-12T03:35:22.740Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><p><a href="https://cli.vuejs.org/zh/">Vue CLI ：官方文档</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>全局安装<code>npm install -g @vue/cli</code>, 一次安装永久使用</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>一、使用 <code>vue ui</code> ,启动可视化面板创建项目</p><p>二、基于交互式命令创建项目</p><p><code>vue create hello-world</code>  (注意项目名不可以有大写)</p><p>输入命令后，会跳出几个选项让你回答：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please pick a present:</span><br><span class="line"><span class="keyword">default</span> <span class="comment">//可以选默认的包含了基本的 Babel + ESLint 设置的 preset</span></span><br><span class="line">Manually select features <span class="comment">//手动配置，根据你需要用方向键选择（按 “空格键”选择/取消选择，A键全选/取消全选）对应功能</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">? Check the features needed <span class="keyword">for</span> your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">&gt;( ) Babel                           <span class="comment">//转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。                      </span></span><br><span class="line"> ( ) TypeScript<span class="comment">// TypeScript是一个JavaScript（后缀.js）的超集（后缀.ts）包含并扩展了 JavaScript 的语法，需要被编译输出为 JavaScript在浏览器运行，目前较少人再用</span></span><br><span class="line"> ( ) <span class="function">Progressive Web <span class="title">App</span> <span class="params">(PWA)</span> Support<span class="comment">// 渐进式Web应用程序</span></span></span><br><span class="line"><span class="function"> <span class="params">( )</span> Router                           <span class="comment">// vue-router（vue路由）</span></span></span><br><span class="line"><span class="function"> <span class="params">( )</span> Vuex                             <span class="comment">// vuex（vue的状态管理模式）</span></span></span><br><span class="line"> ( ) CSS Pre-processors               // CSS 预处理器（如：less、sass）</span><br><span class="line"> ( ) Linter / Formatter               <span class="comment">// 代码风格检查和格式化（如：ESlint）</span></span><br><span class="line"> ( ) Unit Testing                     <span class="comment">// 单元测试（unit tests）</span></span><br><span class="line"> ( ) E2E Testing                      <span class="comment">// e2e（end to end） 测试</span></span><br></pre></td></tr></table></figure><p>选择完后直接enter，然后会提示你选择对应功能的具体工具包，选择自己擅长或者使用广泛的（方便遇到问题时百度）</p><ul><li>是否使用<strong>history router</strong>：</li></ul><p>history：利用了 HTML5 History Interface 中新增的 pushState( ) 和 replaceState( ) 方法（需要特定浏览器支持）。单页客户端应用，history mode 需要后台配置支持（详细参见：<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90">https://router.vuejs.org/zh/guide/essentials/history-mode.html</a>）</p><ul><li><strong>css预处理器</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Check the features needed <span class="keyword">for</span> your project: Router, Vuex, CSS Pre-processors, Linter, Unit</span><br><span class="line"> Pick a CSS pre-<span class="built_in">processor</span> (PostCSS, Autoprefixer <span class="keyword">and</span> CSS Modules are supported by <span class="keyword">default</span>):</span><br><span class="line">&gt; SCSS/SASS  <span class="comment">//Sass安装需要Ruby环境，是在服务端处理的，SCSS 是 Sass3新语法（完全兼容 CSS3且继承Sass功能）</span></span><br><span class="line">  LESS       <span class="comment">//Less最终会通过编译处理输出css到浏览器，Less 既可以在客户端上运行，也可在服务端运行 (借助 Node.js)</span></span><br><span class="line">  Stylus     <span class="comment">//Stylus主要用来给Node项目进行CSS预处理支持，Stylus功能上更为强壮，和js联系更加紧密，可创建健壮的、动态的的CSS。</span></span><br></pre></td></tr></table></figure><ul><li><strong>ESLint</strong>：提供一个插件化的javascript代码检测工具</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Pick a linter / formatter config: (Use arrow keys)</span><br><span class="line">&gt; ESLint with error prevention only </span><br><span class="line">ESLint + Airbnb config</span><br><span class="line">ESLint + Standard config</span><br><span class="line">ESLint + Prettier <span class="comment">//使用较多</span></span><br></pre></td></tr></table></figure><ul><li><strong>何时检测</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)</span><br><span class="line">&gt;( ) Lint on save                    <span class="comment">// 保存就检测</span></span><br><span class="line"> ( ) Lint <span class="keyword">and</span> fix on commit          <span class="comment">// fix和commit时候检查</span></span><br></pre></td></tr></table></figure><ul><li><strong>单元测试</strong> ：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Pick a unit testing solution: (Use arrow keys)</span><br><span class="line">&gt; Mocha + Chai  <span class="comment">//mocha灵活,只提供简单的测试结构，如果需要其他功能需要添加其他库/插件完成。必须在全局环境中安装</span></span><br><span class="line">  Jest          <span class="comment">//安装配置简单，容易上手。内置Istanbul，可以查看到测试覆盖率，相较于Mocha:配置简洁、测试代码简洁、易于和babel集成、内置丰富的expect</span></span><br></pre></td></tr></table></figure><ul><li><strong>如何存放配置</strong> ：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">? Where <span class="keyword">do</span> you prefer placing config <span class="keyword">for</span> Babel, PostCSS, ESLint, etc.? (Use arrow keys)</span><br><span class="line">&gt; In dedicated config files <span class="comment">// 独立文件放置</span></span><br><span class="line">  In package.json <span class="comment">// 放package.json里</span></span><br></pre></td></tr></table></figure><ul><li><strong>是否保存本次配置</strong>（之后可以直接使用）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? Save <span class="keyword">this</span> as a preset <span class="keyword">for</span> future projects? (Y/n) <span class="comment">// y:记录本次配置，然后需要你起个名; n：不记录本次配置</span></span><br></pre></td></tr></table></figure><h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><p><code>npm run serve</code></p><h1 id="vue-cli的webpack配置分析"><a href="#vue-cli的webpack配置分析" class="headerlink" title="vue-cli的webpack配置分析"></a>vue-cli的webpack配置分析</h1><ul><li><p>从<code>package.json</code>可以看到开发和生产环境的入口。</p><img src="https://upload-images.jianshu.io/upload_images/10868449-255932a94e033291.png" alt="img"  /></li><li><p>可以看到dev中的设置，build/webpack.dev.conf.js，该文件是开发环境中webpack的配置入口。</p></li><li><p>在webpack.dev.conf.js中出现webpack.base.conf.js，这个文件是开发环境和生产环境，甚至测试环境，这些环境的公共webpack配置。可以说，这个文件相当重要。</p></li><li><p>还有config/index.js 、build/utils.js 、build/build.js等，具体请看这篇介绍：<br><a href="https://link.jianshu.com/?t=https://segmentfault.com/a/1190000008644830">https://segmentfault.com/a/1190000008644830</a></p></li></ul><h1 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h1><p>注意，自己的项目文件都需要放到 src 文件夹下。<br>在项目开发完成之后，可以输入 <code>npm run build</code> 来进行打包工作。</p><p>另：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.npm</span> 开启了npm run dev以后怎么退出或关闭？</span><br><span class="line">ctrl+c</span><br><span class="line"><span class="number">2</span><span class="selector-class">.--save-dev</span></span><br><span class="line">自动把模块和版本号添加到模块配置文件package<span class="selector-class">.json</span>中的依赖里devdependencies部分</span><br><span class="line"><span class="number">3</span>. --save-dev 与 --save 的区别</span><br><span class="line">--save     安装包信息将加入到dependencies（生产阶段的依赖）</span><br><span class="line">--save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它</span><br></pre></td></tr></table></figure><p>打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看。<br>项目上线时，只需要将 dist 文件夹放到服务器就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cli.vuejs.org/zh/&quot;&gt;Vue CLI ：官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1</summary>
      
    
    
    
    <category term="vue" scheme="https://chengling0824.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://chengling0824.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>一起学习TypeScript(教程合集)</title>
    <link href="https://chengling0824.github.io/2021/04/09/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0TypeScript-%E6%95%99%E7%A8%8B%E5%90%88%E9%9B%86/"/>
    <id>https://chengling0824.github.io/2021/04/09/%E4%B8%80%E8%B5%B7%E5%AD%A6%E4%B9%A0TypeScript-%E6%95%99%E7%A8%8B%E5%90%88%E9%9B%86/</id>
    <published>2021-04-09T02:01:32.000Z</published>
    <updated>2021-04-09T02:03:56.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一起学习TypeScript"><a href="#一起学习TypeScript" class="headerlink" title="一起学习TypeScript"></a>一起学习TypeScript</h1><blockquote><p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript。</p></blockquote><p><a href="https://www.typescriptlang.org/">TypeScript</a> 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p><h2 id="学习目录"><a href="#学习目录" class="headerlink" title="学习目录"></a>学习目录</h2><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#typescript-%E6%95%99%E7%A8%8B">TypeScript 教程</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9TypeScript">为什么选择 TypeScript</a></li><li><a href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">学习资源</a><ul><li><a href="https://github.com/xcatliu/typescript-tutorial">TypeScript 入门教程</a></li><li><a href="#%E8%BF%9B%E9%98%B6">进阶</a></li><li><a href="#%E5%AE%9E%E6%88%98">实战</a></li></ul></li></ul></li><li><a href="#typescript-starterboilerplate">TypeScript Starter/Boilerplate</a></li><li><a href="#typescript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">TypeScript 设计模式</a></li><li><a href="#typescript-%E8%A7%86%E9%A2%91">TypeScript 视频</a><ul><li><a href="#%E4%B8%AD%E6%96%87%E8%A7%86%E9%A2%91">中文视频</a></li><li><a href="#%E8%8B%B1%E6%96%87%E8%A7%86%E9%A2%91">英文视频</a></li></ul></li><li><a href="#typescript-%E9%97%AE%E7%AD%94">TypeScript 问答</a></li><li><a href="#typescript-%E4%B9%A6%E7%B1%8D">TypeScript 书籍</a><ul><li><a href="#%E4%B8%AD%E6%96%87%E4%B9%A6%E7%B1%8D">中文书籍</a></li><li><a href="#%E8%8B%B1%E6%96%87%E4%B9%A6%E7%B1%8D">英文书籍</a></li></ul></li><li><a href="#typescript-%E5%B7%A5%E5%85%B7%E5%BA%93%E6%A1%86%E6%9E%B6">TypeScript 工具/库/框架</a><ul><li><a href="#%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7">构建工具</a><ul><li><a href="#webpack">webpack</a></li><li><a href="#gulp">gulp</a></li><li><a href="#grunt">grunt</a></li><li><a href="#compiler">compiler</a></li><li><a href="#linter">linter</a></li></ul></li><li><a href="#ioc">Ioc</a></li><li><a href="#%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90">文档生成</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li><li><a href="#server">Server</a></li></ul></li><li><a href="#typescript-ide">TypeScript IDE</a><ul><li><a href="#offline">Offline</a><ul><li><a href="#ide%E6%8F%92%E4%BB%B6">IDE/插件</a></li></ul></li><li><a href="#online">Online</a><ul><li><a href="#playground">Playground</a></li><li><a href="#chrome-%E6%89%A9%E5%B1%95">Chrome 扩展</a></li></ul></li></ul></li><li><a href="#%E8%B4%A1%E7%8C%AE">贡献</a><ul><li><a href="#%E6%8C%87%E5%8D%97">指南</a></li></ul></li></ul><hr><h2 id="TypeScript-教程"><a href="#TypeScript-教程" class="headerlink" title="TypeScript 教程"></a>TypeScript 教程</h2><h3 id="为什么选择TypeScript"><a href="#为什么选择TypeScript" class="headerlink" title="为什么选择TypeScript"></a>为什么选择TypeScript</h3><ul><li><a href="https://juejin.im/post/59c46bc86fb9a00a4636f939">蚂蚁金服数据体验技术团队 - TypeScript体系调研报告</a></li><li><a href="https://zhuanlan.zhihu.com/p/21629069">Vilicvane - TypeScript 2.0 新特性一览</a></li><li><a href="https://zhuanlan.zhihu.com/p/24267683">Vilicvane - TypeScript 2.1 新特性一览</a></li><li><a href="https://zhuanlan.zhihu.com/p/25579011">Vilicvane - TypeScript 2.2 新特性一览</a></li><li><a href="https://zhuanlan.zhihu.com/p/27349475">Vilicvane - TypeScript 2.3 新特性一览</a></li><li><a href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript">Microsoft - TypeScript 2.4 新特性一览</a></li><li><a href="https://zhuanlan.zhihu.com/p/30760290">Vilicvane - TypeScript 2.5~2.6 新特性一览</a></li><li><a href="https://zhuanlan.zhihu.com/p/37374083">黄子毅 - 精读&lt;&lt;TypeScript2.0 - 2.9&gt;&gt;</a></li><li><a href="https://zhuanlan.zhihu.com/p/28494162">Linux中国 - 一篇缺失的 TypeScript 介绍</a></li><li><a href="http://www.jianshu.com/p/3c8c7713fa0e">单纯的土豆 - ES5, ES2015 和 TypeScript 的区别</a></li><li><a href="https://zhuanlan.zhihu.com/p/38526585">三七二十 - TypeScript 的好处都有啥？和 JavaScript 的区别在哪？</a></li><li><a href="https://www.jianshu.com/p/0dfbcd4a0757">Grain 先森 - 前端-TypeScript VS JavaScript 深度对比</a></li><li><a href="http://www.jianshu.com/p/27c026734b8d">贺贺v5 - Angular2、Ionic、TypeScript、es6的关系？</a></li><li><a href="http://www.jianshu.com/p/066a6017db1b">极客学院 - 使用 TypeScript 提高开发能力</a></li><li><a href="https://zhuanlan.zhihu.com/p/27695708">Hevin - 为什么 Reddit 选择了 TypeScript？</a></li><li><a href="https://segmentfault.com/a/1190000010892897">JiaXinYi - Angular: 我们为什么选择 TypeScript</a></li><li><a href="http://djcordhose.github.io/flow-vs-typescript/flow-typescript-2.html#/">Djcordhose - 对比 Flow 和 TypeScript</a></li><li><a href="https://github.com/neal1991/articles-translator/blob/master/%E9%87%87%E7%94%A8Flow%E4%BB%A5%E5%8F%8ATypeScript.md">Neal1991 - 采用 Flow 以及 TypeScript</a></li><li><a href="https://zhuanlan.zhihu.com/p/27593029">柳佳 - Flow vs. Typescript</a></li><li><a href="https://sdk.cn/news/6789">SDK.cn - Slack 的 TypeScript 之路</a></li><li><a href="https://segmentfault.com/a/1190000014414303">RDDcoding - 熟悉全栈TypeScript</a></li><li><a href="http://www.lxxyx.win/2017/07/23/2017/ts-accerlate/">Lxxyx - TypeScript - 不止稳，而且快</a></li></ul><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><ul><li><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/">Zhongsp - TypeScript Handbook (中文版)</a></li><li><a href="https://www.w3cschool.cn/typescript/">Bjcl - TypeScript 教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/32112508">Jason - 你所不知道的 Typescript 与 Redux 类型优化</a></li><li><a href="https://zhuanlan.zhihu.com/p/39620591">王亦斯 - 巧用 Typescript</a></li><li><a href="https://jkchao.cn/article/5bb9c63963a5d23d5ce3091b">三毛 - 巧用 TypeScript （一）</a></li><li><a href="https://jkchao.cn/article/5bde8fdf94307c57d4c8d37a">三毛 - 巧用 TypeScript （二）</a></li><li><a href="https://jkchao.cn/article/5befe57994307c57d4c8d383">三毛 - 巧用 TypeScript （三）</a></li><li><a href="https://jkchao.cn/article/5c162137e35fb85c4c7e1278">三毛 - 巧用 TypeScript （四）</a></li><li><a href="https://jkchao.cn/article/5c8a4d99e53a054fad647c15">三毛 - 巧用 TypeScript （五）</a></li><li><a href="https://zhuanlan.zhihu.com/p/38687656">Square - TypeScript 3.0 元组类型的用法和一些奇技淫巧</a></li><li><a href="https://zhuanlan.zhihu.com/p/38789971">Square - Typescript 类型高级技巧，和强约束 bind 的实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/38081852">腾讯NEXT学位 - 深入 TypeScript 的类型系统</a></li><li><a href="https://zhuanlan.zhihu.com/p/30360931">newraina - 手把手教写 TypeScript Transformer Plugin</a></li><li><a href="https://juejin.im/post/5bf7f1c0e51d455ed74f625c">EER - TypeScript 重构 Axios 经验分享</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/">三毛 - 深入理解 TypeScript</a></li></ul><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p><strong>Angular</strong></p><ul><li><a href="https://www.gitbook.com/book/yanxiaodi/ionic2-guide/details">Yanxiaodi - Ionic 2 With TypeScript</a></li><li><a href="https://juejin.im/entry/5811c2cba22b9d00639f69f5">Cacivy - Angular 2 + TypeScript 实现的 Cnode 社区</a></li></ul><p><strong>Vue</strong></p><ul><li><a href="https://segmentfault.com/a/1190000013676663">薯条真的好好吃哦 - almost最好的Vue + Typescript系列01 环境搭建篇</a></li><li><a href="https://segmentfault.com/a/1190000011474717">toBeTheLight - Vue 2.5中将迎来有关TypeScript的改进！</a></li><li><a href="https://segmentfault.com/a/1190000011853167">盘风 - Vue2.5+ Typescript 引入全面指南</a></li><li><a href="https://mp.weixin.qq.com/s/p2Uc9IV284MXbRHhV2Vf-g">腾讯Bugly - vuejs+ts+webpack2框架的项目实践</a></li><li><a href="https://segmentfault.com/a/1190000011520912">LinkFly - 从 JavaScript 到 TypeScript 6 - Vue 引入 TypeScript</a></li><li><a href="https://segmentfault.com/a/1190000012486378">SimonZhanglTer - 可能是最全的Vue-TypeScript教程(附实例代码和一键构建工具)</a></li><li><a href="https://segmentfault.com/a/1190000011878086">三命 - vue + typescript 进阶篇</a></li><li><a href="https://juejin.im/post/5b54886ce51d45198f5c75d7">qiangdada - TypeScript + 大型项目实战</a></li><li><a href="https://segmentfault.com/a/1190000013462418">距离 - Vue全家桶+TypeScript使用总结</a></li><li><a href="https://segmentfault.com/a/1190000014884801">海蓝2018 - vue全家桶+Typescript开发一款习惯养成APP</a></li><li><a href="https://juejin.im/entry/58d8d603b123db199f4639a3">Treri - 使用FIS3 和 TypeScript 实现 vue-hackernews-2.0</a></li><li><a href="https://juejin.im/post/5ba3d205e51d450e8477af33">🍼holyZhengs - 记录一次基于vue、typescript、pwa的项目由开发到部署</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTExNzYwNg==&mid=2247484478&idx=1&sn=a1222cc6d327fe80690b71e4398a27a2&chksm=fbb58ff7ccc206e12b5e2d57fb7cf84f8fe31dce3213e9b2c9ea00d5555873ddbb68ff2fde84&token=1712114111&lang=zh_CN&rd2werd=1#wechat_redirect">大转转FE - 原有vue项目接入typescript</a></li><li><a href="https://juejin.im/post/5bc2fd06e51d450e7903c783">MartinYin - 使用typescript+vue 编写电影信息小项目！</a></li><li><a href="https://jkchao.cn/article/5b3d3bbef9d34142a117b184">三毛 - 在 Vue 中使用 TypeScript 的一些思考（实践）</a></li></ul><p><strong>React</strong></p><ul><li><a href="https://juejin.im/post/5b715796e51d4566334ca28c">fi3ework - 基于 React + TypeScript 的网易云音乐</a></li><li><a href="https://juejin.im/post/595cc34ff265da6c3d6c262b">iKcamp - 翻译 | 开始使用 TypeScript 和 React</a></li><li><a href="https://segmentfault.com/a/1190000016163937">贾顺名 - TypeScript在react项目中的实践</a></li><li><a href="https://juejin.im/post/5bab4d59f265da0aec22629b">花生毛豆 - TypeScript 在 React 中使用总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/42141179">icepy - 复杂 React 应用中的TypeScript 3.0实践</a></li><li><a href="https://juejin.im/post/5a9c004a6fb9a028b92c9e91">蚂蚁金服数据体验技术团队 - TypeScript 实践</a></li><li><a href="https://juejin.im/post/5b07caf16fb9a07aa83f2977">蚂蚁金服数据体验技术团队 - TypeScript 2.8下的终极React组件模式</a></li></ul><p><strong>React Native</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/27029898">胡桓铭 - React Native 与 TypeScript 在企业开发中的实践</a></li></ul><p><strong>Wechat</strong></p><ul><li><a href="https://segmentfault.com/a/1190000008175944">Guyoung - 使用 TypeScript 开发微信小程序</a></li></ul><p><strong>Node.js</strong></p><ul><li><a href="https://www.jianshu.com/p/6aab86403dc1">MarxJiao - 使用webpack搭建基于typescript的node开发环境</a></li><li><a href="https://zhuanlan.zhihu.com/p/35334932">天猪 - 当 Egg 遇到 TypeScript，收获茶叶蛋一枚</a></li><li><a href="https://75team.com/post/thinkjs-3.0-with-typescript.html">奇舞团 - ThinkJS 3.0 如何实现对 TypeScript 的支持</a></li><li><a href="https://segmentfault.com/a/1190000015719697">贾顺名 - TypeScript在node项目中的实践</a></li><li><a href="https://mp.weixin.qq.com/s/agjjsO-47Qdd517wthadFg">贾顺名 - 使用 TS + Sequelize 实现更简洁的 CRUD</a></li><li><a href="https://juejin.im/post/5b89e47f51882542c062651f">YDJFE - 一次TypeScript, React, Node, MongoDB的模板式前后端分离开发实践</a></li></ul><hr><h2 id="TypeScript-设计模式"><a href="#TypeScript-设计模式" class="headerlink" title="TypeScript 设计模式"></a>TypeScript 设计模式</h2><ul><li><a href="https://juejin.im/post/59fa88ac5188255a6a0d5f31">蚂蚁金服数据体验技术团队 - Typescript玩转设计模式 之 创建型模式</a></li><li><a href="https://juejin.im/post/5a2d16325188252da0535d73">蚂蚁金服数据体验技术团队 - Typescript玩转设计模式 之 结构型模式（上）</a></li><li><a href="https://juejin.im/post/5a51da10f265da3e347b1483">蚂蚁金服数据体验技术团队 - Typescript玩转设计模式 之 结构型模式（下）</a></li><li><a href="https://juejin.im/post/5a6dd4dd51882573385ffa8e">蚂蚁金服数据体验技术团队 - Typescript玩转设计模式 之 对象行为型模式（上）</a></li><li><a href="https://juejin.im/post/5a77211b6fb9a0635774d61a">蚂蚁金服数据体验技术团队 -Typescript玩转设计模式 之 对象行为型模式（下）</a></li><li><a href="https://zhuanlan.zhihu.com/p/43283016">杜帅 - 浅析Typescript设计模式</a></li><li><a href="https://github.com/torokmark/design_patterns_in_typescript">torokmark - design_patterns_in_typescript</a></li></ul><hr><h2 id="TypeScript-书籍"><a href="#TypeScript-书籍" class="headerlink" title="TypeScript 书籍"></a>TypeScript 书籍</h2><h3 id="中文书籍"><a href="#中文书籍" class="headerlink" title="中文书籍"></a>中文书籍</h3><ul><li><a href="https://item.jd.com/12001593.html">Learning TypeScript (中文版)</a></li><li><a href="https://item.jd.com/11948831.html">迈向 Angular 2: 基于 TypeScript 的高性能 SPA 框架</a></li></ul><h3 id="英文书籍"><a href="#英文书籍" class="headerlink" title="英文书籍"></a>英文书籍</h3><ul><li><a href="https://www.amazon.cn/dp/B00OUJL6P0">TypeScript Essentials</a></li><li><a href="https://www.amazon.cn/dp/B00WMLHQFC">Mastering TypeScript</a></li><li><a href="https://www.amazon.cn/dp/B01DPR2EQC/">Mastering TypeScript - Second Edition</a></li><li><a href="https://www.amazon.cn/dp/B0151N0G7W/">Learning TypeScript</a></li><li><a href="https://www.amazon.cn/dp/B078PQ6MF4/">Learning TypeScript 2.x</a></li><li><a href="https://www.amazon.cn/dp/B075V9K4CC/">TypeScript 2.x By Example</a></li><li><a href="https://www.amazon.cn/dp/B0753J1W3Z">TypeScript 2.x for Angular Developers</a></li><li><a href="https://www.amazon.cn/dp/1617293121">Angular 2 Development with TypeScript </a></li><li><a href="https://www.amazon.cn/dp/B01MZ2PTHY/">TypeScript: Modern JavaScript Development</a></li><li><a href="https://www.amazon.cn/dp/B01CUI0JW8">TypeScript Blueprints</a></li><li><a href="https://www.amazon.cn/dp/1484232488">Pro TypeScript</a></li><li><a href="https://www.amazon.cn/dp/B01BSTEDI6/">TypeScript Design Patterns</a></li><li><a href="https://www.amazon.cn/dp/B071VVFD4D/">TypeScript High Performance</a></li><li><a href="https://www.amazon.cn/dp/B078N3XCVG/">TypeScript Microservices</a></li></ul><hr><h2 id="TypeScript-工具-库-框架"><a href="#TypeScript-工具-库-框架" class="headerlink" title="TypeScript 工具/库/框架"></a>TypeScript 工具/库/框架</h2><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><ul><li><a href="https://github.com/s-panferov/awesome-typescript-loader">s-panferov - awesome-typescript-loader</a></li><li><a href="https://github.com/TypeStrong/ts-loader">TypeStrong - ts-loader</a></li></ul><h4 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h4><ul><li><a href="https://github.com/ivogabe/gulp-typescript">ivogabe - gulp-typescript</a></li></ul><h4 id="grunt"><a href="#grunt" class="headerlink" title="grunt"></a>grunt</h4><ul><li><a href="https://github.com/TypeStrong/grunt-ts">TypeStrong - grunt-ts</a></li></ul><h4 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h4><ul><li><a href="https://github.com/TypeStrong/ts-node">TypeStrong - ts-node</a></li><li><a href="https://github.com/AssemblyScript/assemblyscript">AssemblyScript - assemblyscript</a></li><li><a href="https://github.com/bcherny/json-schema-to-typescript">bcherny - json-schema-to-typescript</a></li><li><a href="https://github.com/YousefED/typescript-json-schema">YousefED - typescript-json-schema</a></li></ul><h4 id="linter"><a href="#linter" class="headerlink" title="linter"></a>linter</h4><ul><li><a href="https://github.com/palantir/tslint">palantir - tslint</a></li></ul><h3 id="Ioc"><a href="#Ioc" class="headerlink" title="Ioc"></a>Ioc</h3><ul><li><a href="https://github.com/inversify/InversifyJS">Inversify - InversifyJS</a></li><li><a href="https://github.com/inversify/inversify-express-example">Inversify - inversify-express-example</a></li></ul><h3 id="文档生成"><a href="#文档生成" class="headerlink" title="文档生成"></a>文档生成</h3><ul><li><a href="https://github.com/TypeStrong/typedoc">TypeStrong - typedoc</a></li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><a href="https://github.com/dcodeIO/protobuf.js">dcodeIO - protobuf.js</a></li><li><a href="https://github.com/basarat/typescript-collections">basarat - typescript-collections</a></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><a href="https://github.com/typeorm/typeorm">Typeorm - typeorm</a></li><li><a href="https://github.com/RobinBuschmann/sequelize-typescript">RobinBuschmann - sequelize-typescript</a></li></ul><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><ul><li><a href="https://eggjs.org/">Alibaba - egg.js</a></li><li><a href="https://github.com/thinkjs/thinkjs">welefen - thinkjs</a></li><li><a href="https://github.com/nestjs/nest">kamilmysliwiec - nest</a></li></ul><hr><h2 id="TypeScript-IDE"><a href="#TypeScript-IDE" class="headerlink" title="TypeScript IDE"></a>TypeScript IDE</h2><h3 id="Offline"><a href="#Offline" class="headerlink" title="Offline"></a>Offline</h3><h4 id="IDE-插件"><a href="#IDE-插件" class="headerlink" title="IDE/插件"></a>IDE/插件</h4><ul><li><a href="https://visualstudio.microsoft.com/zh-hans/vs/community/">Visual Studio Community</a></li><li><a href="https://www.visualstudio.com/en-us/products/code-vs.aspx">Visual Studio Code</a></li><li><a href="https://www.jetbrains.com/webstorm/">WebStorm</a></li><li><a href="https://www.jetbrains.com/phpstorm/download/">PhpStorm</a></li><li><a href="https://github.com/Microsoft/TypeScript-Sublime-Plugin">TypeScript Sublime Plugin</a></li><li><a href="https://github.com/TypeStrong/atom-typescript">Atom TypeScript</a></li><li><a href="https://github.com/ananthakumaran/tide">TypeScript Interactive Development Environment for Emacs</a></li><li><a href="http://typecsdev.com/">TypeScript IDE for Eclipse</a></li><li><a href="https://github.com/leafgarland/typescript-vim">TypeScript Syntax for VIM</a></li></ul><h3 id="Online"><a href="#Online" class="headerlink" title="Online"></a>Online</h3><h4 id="Playground"><a href="#Playground" class="headerlink" title="Playground"></a>Playground</h4><ul><li><a href="http://www.typescriptlang.org/Playground/">TypeScript official Playground</a></li><li><a href="https://stackblitz.com/">Stackblitz</a></li><li><a href="http://jsbin.com/?js">JS Bin</a></li><li><a href="http://codepen.io/">Codepen</a></li><li><a href="http://drake7707.github.io/Typescript-Editor/">TypeScript Editor</a></li><li><a href="http://niutech.github.io/typescript-interpret/">TypeScript Interpret - Terminal Emulator</a></li><li><a href="https://agentcooper.github.io/typescript-play/">TypeScript Play</a></li></ul><h4 id="Chrome-扩展"><a href="#Chrome-扩展" class="headerlink" title="Chrome 扩展"></a>Chrome 扩展</h4><ul><li><a href="https://github.com/OctoLinker/browser-extension">OctoLinker</a></li></ul>]]></content>
    
    
    <summary type="html">TypeScript is a typed superset of JavaScript that compiles to plain JavaScript。[TypeScript](https://www.typescriptlang.org/) 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程...</summary>
    
    
    
    <category term="TypeScript" scheme="https://chengling0824.github.io/categories/TypeScript/"/>
    
    
    <category term="TypeScript" scheme="https://chengling0824.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>css浮动</title>
    <link href="https://chengling0824.github.io/2021/04/01/css%E6%B5%AE%E5%8A%A8/"/>
    <id>https://chengling0824.github.io/2021/04/01/css%E6%B5%AE%E5%8A%A8/</id>
    <published>2021-04-01T06:51:24.000Z</published>
    <updated>2021-04-12T03:33:05.605Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><blockquote><p>浮动的定义：使元素脱离文档流，按照指定方向（左右）发生移动，遇到父级边界或者相邻的浮动元素停了下来。</p></blockquote><h1 id="浮动中将会遇到的问题"><a href="#浮动中将会遇到的问题" class="headerlink" title="浮动中将会遇到的问题"></a>浮动中将会遇到的问题</h1><h2 id="第一种情况-导致的各种布局混乱问题"><a href="#第一种情况-导致的各种布局混乱问题" class="headerlink" title="第一种情况 导致的各种布局混乱问题"></a>第一种情况 导致的各种布局混乱问题</h2><blockquote><p>（浮动元素不占位置导致的布局变化）</p></blockquote><h2 id="第二种情况-浮动的元素只影响他后面的元素-根据层叠顺序推算"><a href="#第二种情况-浮动的元素只影响他后面的元素-根据层叠顺序推算" class="headerlink" title="第二种情况 浮动的元素只影响他后面的元素    根据层叠顺序推算"></a>第二种情况 浮动的元素只影响他后面的元素    根据层叠顺序推算</h2><h2 id="第三种情况-导致的各种掉盒子问题"><a href="#第三种情况-导致的各种掉盒子问题" class="headerlink" title="第三种情况 导致的各种掉盒子问题"></a>第三种情况 导致的各种掉盒子问题</h2><p>如果父级宽度太窄，无法容纳所有元素，无法容纳的元素会掉下去，之后还是会执行浮动，向左/右直到遇到边框就会停下来！</p><h2 id="第四种情况-导致的各种被卡住问题"><a href="#第四种情况-导致的各种被卡住问题" class="headerlink" title="第四种情况 导致的各种被卡住问题"></a>第四种情况 导致的各种被卡住问题</h2><blockquote><p>浮动的元素高度不同，并且外面盒子宽度不够的情况下，往下掉的过程中可能会被卡住（掉出来后盒子仍向左/右执行浮动）</p></blockquote><h1 id="float元素的特性"><a href="#float元素的特性" class="headerlink" title="float元素的特性"></a>float元素的特性</h1><ul><li><p>设置了浮动的元素，变成浮动元素，具备浮动元素特性</p></li><li><p>都支持横排显示 </p></li><li><p>都支持宽高  </p></li><li><p>不给宽度的时候默认内容撑开宽高  </p></li><li><p>支持margin padding  </p></li><li><p>不支持margin:auto;  </p></li><li><p>浮动脱离文档流  </p></li><li><p>浮动提升层级半级 概念性理解，其实和层级没关系，只有定位有层级</p></li></ul><h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><h2 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h2><blockquote><p>浮动元素不占位置，由于不占位置导致父级的塌陷影响布局 （内容为0高度，父级高度由内容撑开的时候，也为0）</p></blockquote><h2 id="清除浮动的原则（清除浮动乃是清除浮动给父级带来的影响）"><a href="#清除浮动的原则（清除浮动乃是清除浮动给父级带来的影响）" class="headerlink" title="清除浮动的原则（清除浮动乃是清除浮动给父级带来的影响）"></a>清除浮动的原则（清除浮动乃是清除浮动给父级带来的影响）</h2><p>1.浮动元素本身不能清除浮动 比如div 设置了float 不能直接给div 运用clear来清除浮动   </p><p>2.哪里浮动，哪里给父元素清除！即浮动之后要立马解决这里由于浮动带来的影响！ 以免对后面的布局造成影响！</p><h2 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h2><h3 id="子元素方式：添加空标签"><a href="#子元素方式：添加空标签" class="headerlink" title="子元素方式：添加空标签"></a>子元素方式：添加空标签</h3><blockquote><p>在需要清除浮动的元素前面添加一个空的div</p><p>浮动元素本身不能清除浮动</p></blockquote><p><code>&lt;div style=&#39;clear:both;&#39;&gt;&lt;/div&gt;</code></p><h3 id="给父级用的方法"><a href="#给父级用的方法" class="headerlink" title="给父级用的方法"></a>给父级用的方法</h3><ol><li><p>给父元素添加高度  缺点是扩展性不好，一般都是内容撑开高度  </p></li><li><p>给父级inline­block  缺点是中间会解析空格   </p></li><li><p>overflow:hidden;  需要溢出隐藏的时候你就写，这样就不用写清楚浮动的样了   </p></li></ol><blockquote><p>在父元素上设置overflow这个属性，如果父元素的这个属性设置为auto或者是hidden，父元素就会扩展包含浮动</p></blockquote><ol start="4"><li>after伪类</li></ol><blockquote><p>利用伪类元素来清除有浮动的标签，也就定义一个公共的类clearfix，给这个类添加css属性，在里面进行清除浮动的操作。只要哪里需要清除浮动，就在哪里添加一个清除浮动的类</p></blockquote><blockquote><p>这种方式这样理解，就是利用伪类元素，也就是在有浮动的标签前面添加一个块级元素，来达到效果。</p><p><code>.clearfix:after&#123;content:&#39;&#39;;display:block;clear:both;&#125; </code></p></blockquote><blockquote><p>解决低版本ie的兼容性问题 :</p><p><code>.clearfix&#123;zoom：1；&#125; </code></p></blockquote>]]></content>
    
    
    <summary type="html">浮动的定义：使元素脱离文档流，按照指定方向（左右）发生移动，遇到父级边界或者相邻的浮动元素停了下来。 浮动中将会遇到的问题：第一种情况 导致的各种布局混乱问题  （浮动元素不占位置导致的布局变化）第二种情况 浮动的元素只影响他后面的元素   根据层叠顺序推算  第三种情况 导致的各种掉盒子问题...</summary>
    
    
    
    <category term="css" scheme="https://chengling0824.github.io/categories/css/"/>
    
    
    <category term="css" scheme="https://chengling0824.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>git基本操作</title>
    <link href="https://chengling0824.github.io/2021/04/01/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://chengling0824.github.io/2021/04/01/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2021-04-01T06:51:24.000Z</published>
    <updated>2021-04-12T03:32:49.237Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h1><h2 id="git的基本操作逻辑"><a href="#git的基本操作逻辑" class="headerlink" title="git的基本操作逻辑"></a>git的基本操作逻辑</h2><p><img src="https://pic4.zhimg.com/80/v2-aab55876b59f599900388a43db9ec69f_720w.jpg"></p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><ol><li>克隆版本库 git clone</li><li>获取更新，查看其他人的进程 git feach</li><li>取回更新，与本地合并 git pull</li><li>推送本地代码到远程主机 git push</li></ol>]]></content>
    
    
    <summary type="html">git的基本操作逻辑 常用指令：1. 克隆版本库 git clone 2. 获取更新，查看其他人的进程 git feach 3. 取回更新，与本地合并 git pull 4. 推送本地代码到远程主机 git push</summary>
    
    
    
    
    <category term="git" scheme="https://chengling0824.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Angular,React,Vue三大框架的比较</title>
    <link href="https://chengling0824.github.io/2021/04/01/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://chengling0824.github.io/2021/04/01/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2021-04-01T06:51:24.000Z</published>
    <updated>2021-04-12T03:33:20.489Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Angular-React-Vue三大框架的比较"><a href="#Angular-React-Vue三大框架的比较" class="headerlink" title="Angular,React,Vue三大框架的比较"></a>Angular,React,Vue三大框架的比较</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Angular是基于 TypeScript 的 Javascript 框架。</p><p>它是三大框架里最早针对页面性能问题提出的优化探索，并在2010年由Google对外发布，react、vue后面相继出现。然而Angular由于最早开始，那时候移动端还没有兴起，一开始定位的Web端有些不适应后来的移动端趋势，导致后面有个大的版本迭代。Angular团队在保持<strong>性能优化</strong>的核心方案的同时，适应<strong>移动端化、组件化</strong>的大热潮流，2016年推出了Angular2。并且官方团队在2018年将AngularJS宣布将进行LTS长期维护时间，以后将不再提供支持和更新。虽然目前很多团队的应用还是基于AngularJS，官方也建议尽快迁移。</p><p>React被描述为 “用于构建用户界面的 JavaScript 库”。</p><p>由Facebook在2013年正式对外发布，并一直由Facebook团队负责维护和推广。在 Chris Cordle 这篇文章的统计中，React 在 Facebook 上的使用远远多于 Angular 在 Google 上的使用。React 还被 Airbnb，Uber，Netflix，Twitter，Pinterest，Reddit，Udemy，Wix，Paypal，Imgur，Feedly，Stripe，Tumblr，Walmart 等使用（根据 Facebook, stackshare 和 libscore.com 提供的数据）。</p><p>Vue是近年国内发展最为迅速的 JS 框架。<br><img src="https://user-gold-cdn.xitu.io/2019/6/30/16ba79460127cd31?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br>这里可以看出，在国内，Vue的新潮不是空穴来风，它的热搜量还是稳居第一并继续持续提升的趋势。React, Angular都相对平缓。</p><p>但在国外，react仍占大头，Google趋势如下 :<br><img src="https://user-gold-cdn.xitu.io/2019/6/30/16ba78948101c826?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="Vue与AngularJS的区别"><a href="#Vue与AngularJS的区别" class="headerlink" title="Vue与AngularJS的区别"></a>Vue与AngularJS的区别</h2><p>相同点： 都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。<br>不同点：AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。</p><h2 id="Vue与React的区别"><a href="#Vue与React的区别" class="headerlink" title="Vue与React的区别"></a>Vue与React的区别</h2><p>相同点：React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。<br>不同点：React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。</p><h2 id="一点预测"><a href="#一点预测" class="headerlink" title="一点预测"></a>一点预测</h2><ol><li><p>从市场份额来看，React目前依旧占大额，但以后说不好，毕竟有个BSD license的问题争论。（很多公司和个人都已经迁移，因为目前Facebook旗下很多开源项目还都是BSD, 不确定哪天Facebook又把React切换回BSD。） Angular的趋势平缓，且有Google团队的支持，应该以后依旧会保持着现有的状态。Vue新贵虽然目前市场份额不大，但是发展趋势很迅猛，且跟多家大平台合作，在国内的资讯、媒体、社区都很活跃，所以发展前景还是可观的。</p></li><li><p>从社区支持来看，前面已经说过，Facebook支持着React，而Google支持着Angular，因此这两种框架的增长是毋庸置疑的。它们能够持续得到更新与发布，在碰到迁移时也有着很好的维护与支持。<br>React和Angular的开发人员都声称：升级不是问题，他们会每六个月发布一次主要更新。另外，由于Angular是一个完备的框架，而React是一组更独立、更快捷、且不断改进的库，因此React比Angular更灵活。不过，您也必须关注那些可能不再被支持或维护的小模块。而Vue这方面更缺失，没有一个明确的长远版本规划的路线图。</p></li><li><p>从框架、库角度来说，Angular是一个完备的框架，您不必查看各种库、路由方案和其具体结构，就能快速地开始构建。虽然Angualr4系列之后也在逐步减重，但不得不说，相比较React和Vue相对来说，还是厚重一些。React可以集成很多库来无缝连接搭建应用，但也因此导致React出错率和依赖性都偏高一些。Vue则是平衡了内部依赖和灵活性这块儿，所以相对来说轻而方便使用。</p></li><li><p>从学习曲线来看，Angular和React都有自己的一套，尤其Angular还有依赖注入的层次结构概念，很多都自己集成了，学习成本偏高。从这点来说，Vue的门槛真的很低。难怪现在很多公司偏向Vue, 人力成本低。</p></li></ol><p>随着微应用和微服务的兴起，React和Vue的灵活性更适合开发。Angular更偏单页应用。但Angular是最早拥抱typescript的(在npm2018年的调研中，编译js方法里以46%的占比一跃成为第二，紧跟Babel之后)，也是最早将RxJS思想贯彻到底的框架。</p>]]></content>
    
    
    <summary type="html">背景介绍：Angular是基于 TypeScript 的 Javascript 框架。它是三大框架里最早针对页面性能问题提出的优化探索，并在2010年由Google对外发布，react、vue后面相继出现。然而Angular由于最早开始，那时候移动端还没有兴起，一开始定位的Web端有些不适应后来的移动端趋势，导致后面有个大的版本迭代。Angular团队在保持**性能优化**的核心方案的同时，适应**移动端化、组件化**的大热潮流</summary>
    
    
    
    
    <category term="前端框架" scheme="https://chengling0824.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>设置hexo首页只显示部分摘要（不显示全文）</title>
    <link href="https://chengling0824.github.io/2021/04/01/hexo%E6%A0%B7%E5%BC%8F%E8%B0%83%E6%95%B4%E8%AE%B0%E5%BD%95/"/>
    <id>https://chengling0824.github.io/2021/04/01/hexo%E6%A0%B7%E5%BC%8F%E8%B0%83%E6%95%B4%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-01T06:51:24.000Z</published>
    <updated>2021-04-09T01:57:53.892Z</updated>
    
    <content type="html"><![CDATA[<p>首先，修改配置</p><p>首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>然后，有两种方法：</p><p>方法一：写概述</p><p>在文章的<code>front-matter</code>中添加<code>description</code>，其中description中的内容就会被显示在首页上，其余一律不显示。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>方法二：文章截断</p><p>在需要截断的地方加入：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。<br>例如本文会显示到<code>修改配置</code>上面。</p>]]></content>
    
    
    <summary type="html">首先，需要先修改配置 首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)  然后，有两种方法：方法一：写概述 在文章的`front-matter`中添加`description`，其中description中的内容就会被显示在首页上，其余一律不显示。</summary>
    
    
    
    <category term="hexo—theme-next" scheme="https://chengling0824.github.io/categories/hexo%E2%80%94theme-next/"/>
    
    
    <category term="hexo" scheme="https://chengling0824.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>2020 前端技术发展回顾</title>
    <link href="https://chengling0824.github.io/2021/04/01/2020-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E5%9B%9E%E9%A1%BE/"/>
    <id>https://chengling0824.github.io/2021/04/01/2020-%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E5%9B%9E%E9%A1%BE/</id>
    <published>2021-04-01T06:45:52.000Z</published>
    <updated>2021-04-09T01:51:36.570Z</updated>
    
    <content type="html"><![CDATA[<p>2020 前端技术发展回顾：</p><p><a href="https://zhuanlan.zhihu.com/p/343552059?utm_source=wechat_timeline&amp;utm_medium=social&amp;utm_oi=42082701934592">https://zhuanlan.zhihu.com/p/343552059?utm_source=wechat_timeline&amp;utm_medium=social&amp;utm_oi=42082701934592</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2020 前端技术发展回顾：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/343552059?utm_source=wechat_timeline&amp;amp;utm_medium=social&amp;amp;utm_oi=4208270</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://chengling0824.github.io/2021/03/30/vue%E5%9F%BA%E7%A1%80/"/>
    <id>https://chengling0824.github.io/2021/03/30/vue%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-30T03:43:27.630Z</published>
    <updated>2021-04-17T16:25:33.983Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式框架</strong>。</p></blockquote><h1 id="vue响应式系统"><a href="#vue响应式系统" class="headerlink" title="vue响应式系统"></a>vue响应式系统</h1><p>Vue为MVVM框架，MVVM是前端页面的分层开发思想，主要关注于 视图层 分离。也就是说：MVVM把前端的视图层，分为了三部分 Model, View,  ViewModel</p><ul><li>Model 是 页面中，需要用到的数据</li><li>View 是页面中的HTML结构；</li><li>ViewModel 是 一个 中间的调度者,提供了双向数据绑定的概念；</li></ul><p>当数据模型data变化时，页面视图会得到响应更新，其原理对data的getter/setter方法进行拦截（Object.defineProperty或者Proxy），利用发布订阅的设计模式，在getter方法中进行订阅，在setter方法中发布通知，让所有订阅者完成响应。</p><p>在响应式系统中，Vue会为数据模型data的每一个属性新建一个订阅中心作为发布者，而监听器watch、计算属性computed、视图渲染template/render三个角色同时作为订阅者，对于监听器watch，会直接订阅观察监听的属性，对于计算属性computed和视图渲染template/render，如果内部执行获取了data的某个属性，就会执行该属性的getter方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的setter方法，从而完成该属性的发布通知，通知所有订阅者进行更新。</p><h1 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h1><blockquote><p>指令带有前缀 v-，以表示它们是 Vue 提供的特殊 attribute。它们会在渲染的 DOM 上应用特殊的响应式行为。</p></blockquote><h2 id="v-clock-解决文字闪动的问题"><a href="#v-clock-解决文字闪动的问题" class="headerlink" title="v-clock 解决文字闪动的问题"></a>v-clock 解决文字闪动的问题</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol><li>提供样式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[v-clock]&#123;</span><br><span class="line">    display:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在插值表达式所在的标签中添加v-clock指令<br>先通过样式隐藏内容，然后在内存中进行值的替换，替换好后显示最终的结果。（解决了文字闪动的问题）</li></ol><h2 id="文本插值与-v-text、v-html、v-pre"><a href="#文本插值与-v-text、v-html、v-pre" class="headerlink" title="文本插值与 v-text、v-html、v-pre"></a>文本插值与 v-text、v-html、v-pre</h2><p>v-text<br>v-html<br>v-pre : 显示原始信息，跳过编译过程</p><h2 id="数据响应式与-v-once"><a href="#数据响应式与-v-once" class="headerlink" title="数据响应式与 v-once"></a>数据响应式与 v-once</h2><blockquote><p>数据响应式：数据和 DOM 被建立某种关联，数据的变化导致页面内容的变化</p></blockquote><p>v-once：只编译一次，不具有响应式功能</p><h2 id="属性绑定-v-bind-："><a href="#属性绑定-v-bind-：" class="headerlink" title="属性绑定 v-bind / ："></a>属性绑定 v-bind / ：</h2><h3 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h3><p><strong>对象语法</strong>：<code>v-bind:class(类名: data中属性，值为true就会添加该样式)&quot;</code></p><p>v-bind:class={类名1:data中的属性1，类名2:data中的属性2}</p><p><strong>数组语法</strong>：class类名放在<strong>data</strong>属性中当做值，然后将<strong>data</strong>中的值放在数组中渲染给元素<code> v-bind:class&quot;[data属性名1，data属性名2]&quot;</code></p><p><strong>style绑定</strong>：<code>v-bind:style&#123;color颜色名: data中的属性名&#125;</code>或<code>v-bind:style=&quot;[data属性名1，data属性名2]&quot;</code></p><h2 id="双向数据绑定-v-model"><a href="#双向数据绑定-v-model" class="headerlink" title="双向数据绑定 v-model"></a>双向数据绑定 v-model</h2><p>实现<strong>表单输入</strong>和应用状态之间的双向绑定</p><p><code>v-model=&#39;msg&#39;</code>相当于<code>v-bind:value=&quot;msg&quot; v-on:input=&#39;msg=$event.target.value&#39;</code>,实时更新msg的值</p><h2 id="事件监听-v-on"><a href="#事件监听-v-on" class="headerlink" title="事件监听 v-on / @"></a>事件监听 v-on / @</h2><p><code>@click=&#39;num++&#39;</code> （num在data中定义）</p><p><code>@click=&#39;handle&#39;</code>或<code>@click=&#39;handle()&#39;</code>    （handle函数在methods中定义）</p><blockquote><p>在methods中，this是vue的实例对象</p></blockquote><h2 id="分支循环结构"><a href="#分支循环结构" class="headerlink" title="分支循环结构"></a>分支循环结构</h2><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><p>v-if</p><p>v-else</p><p>v-else-if</p><p>v-show</p><h3 id="循环结构-v-for"><a href="#循环结构-v-for" class="headerlink" title="循环结构 v-for"></a>循环结构 v-for</h3><p>v-for遍历数组：<code>v-for=&quot;(item, index) in list :key=&quot;item.id&quot;&quot;</code></p><p>v-for遍历对象：<code> v-for (属性值v, 属性名k，索引 i )in 遍历的对象</code></p><h2 id="时间修饰符"><a href="#时间修饰符" class="headerlink" title="时间修饰符"></a>时间修饰符</h2><h3 id="stop-阻止冒泡"><a href="#stop-阻止冒泡" class="headerlink" title=".stop 阻止冒泡"></a>.stop 阻止冒泡</h3><p>调用<code>event.stopPropagation( )</code></p><h3 id="prevent-阻止默认行为"><a href="#prevent-阻止默认行为" class="headerlink" title=".prevent 阻止默认行为"></a>.prevent 阻止默认行为</h3><p>调用<code>event.preventDefault( )</code></p><p><code> v-on:click.prevent.self</code> 阻止所有点击</p><p><code>v-on:click.self.prevent</code> 阻止自身的点击</p><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><p>.capture 添加事件侦听器时使用capture模式</p><p>.self 事件从侦听器绑定元素本身触发时才触发回调</p><p>.once 只触发一次</p><p>.passive</p><h2 id="按键修饰符-keyup"><a href="#按键修饰符-keyup" class="headerlink" title="按键修饰符 .keyup"></a>按键修饰符 .keyup</h2><blockquote><p>在监听键盘事件时，我们需要检查详细的按键。Vue允许为<code>v-on</code>在监听键盘时添加按键修饰符：</p></blockquote><h3 id="按键码"><a href="#按键码" class="headerlink" title="按键码"></a>按键码</h3><p><code>.enter</code>，<code>.tab</code>，<code>.delete</code>(捕获‘删除’键和‘退格’键)，<code>.esc</code></p><p><code>.up</code>，<code>.down</code>，<code>.left</code>，<code>.right</code></p><h3 id="自定义按键修饰符"><a href="#自定义按键修饰符" class="headerlink" title="自定义按键修饰符"></a>自定义按键修饰符</h3><p>可以通过<code>config.keyCodes</code>对象自定义<strong>按键修饰符别名</strong>，如<code>Vue.config.keyCodes.f1 = 11</code></p><h1 id="自定义指令、计算、侦听、过滤器、生命周期"><a href="#自定义指令、计算、侦听、过滤器、生命周期" class="headerlink" title="自定义指令、计算、侦听、过滤器、生命周期"></a>自定义指令、计算、侦听、过滤器、生命周期</h1><h2 id="基于vue的表单操作"><a href="#基于vue的表单操作" class="headerlink" title="基于vue的表单操作"></a>基于vue的表单操作</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>input 单行文本</p><p>textarea 多行文本</p><p>select 下拉多选</p><p>type=”radio” 单选框</p><p>type=”checkbox” 多选框</p><blockquote><p>表单元素被选中的规则： </p><p>1：通过v-model绑定data中的属性，该属性中的值就是表单对象中要显示的内容。 </p><p> 2：data中属性可以是单个值，多个值则放在数组中，每一项用’ ‘引号包裹，逗号隔开。  </p><p>3：多选框规律：因为v-model绑定了data中的属性，该元素中的value=1值，对应的就是data属性数组中的值，有几个多选框就会显示几个。</p></blockquote><h3 id="表单域修饰符"><a href="#表单域修饰符" class="headerlink" title="表单域修饰符"></a>表单域修饰符</h3><p>v-model.number：转化为数值，方便运算</p><p>v-model.trim：去掉开始和结尾的空格</p><p>v-model.lazy：将input事件转化为change事件（失去焦点时触发）</p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h3 id="全局定义自定义指令"><a href="#全局定义自定义指令" class="headerlink" title="全局定义自定义指令"></a>全局定义自定义指令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义指令的语法规则</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>&#123;</span><br><span class="line">inserted:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line"><span class="comment">//获取元素的焦点</span></span><br><span class="line">el.focus();</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义指令用法</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; v-focus&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带参数的自定义指令</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;color&#x27;</span>&#123;</span><br><span class="line">    <span class="comment">//bind：绑定事件函数</span></span><br><span class="line">bind:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">el.style.backgroundColor = binding.value.color;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;带参数的自定义指令的用法</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; v-color&#x3D;&#39;&#123;color:&quot;orange&quot;&#125;&#39;&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义局部指令"><a href="#自定义局部指令" class="headerlink" title="自定义局部指令"></a>自定义局部指令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data:&#123;&#125;,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//通过directive创建的指令为局部指令，Vue.directive为全局指令</span></span><br><span class="line">    directives:&#123;</span><br><span class="line">        focus:</span><br><span class="line">        inserted:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    el.focus();</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><blockquote><p>计算属性可以使模板内容更加简洁，更易维护</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter（vm.reversedMessage）</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于格式逻辑复杂的函数，使用计算属性能使内容更加简洁。compuetd计算属性名，对应{ }对象，对象中的属性名对应了处理函数<strong>function</strong>,  该函数的处理结果能返回给计算属性。</p><h3 id="计算属性与方法的区别"><a href="#计算属性与方法的区别" class="headerlink" title="计算属性与方法的区别"></a>计算属性与方法的区别</h3><p>计算属性基于依赖进行缓存（如果值不变，则直接从缓存中拿结果，不进行二次调用），效率高，性能好</p><p>方法不缓存（用一次调一次），性能开销较大</p><h3 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h3><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p><h2 id="侦听器-watch"><a href="#侦听器-watch" class="headerlink" title="侦听器 watch"></a>侦听器 watch</h2><blockquote><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。<strong>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</strong></p></blockquote><p>侦听属性watch一般用于异步或者开销较大的操作，比如通过ajax接口拿数据，和settimeout异步任务</p><p><img src="vue%E5%9F%BA%E7%A1%80.assets/6fea0cd84379485dbe3854482e160aab~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><blockquote><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值和 <code>v-bind</code> 表达式</strong> (后者从 2.1.0+ 开始支持)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;过滤器的使用</span><br><span class="line">&lt;!-- 在双花括号中 --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 &#96;v-bind&#96; 中 --&gt;</span><br><span class="line">&lt;div v-bind:id&#x3D;&quot;rawId | formatId&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义过滤器（全局）"><a href="#自定义过滤器（全局）" class="headerlink" title="自定义过滤器（全局）"></a>自定义过滤器（全局）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">&#x27;过滤器名称&#x27;</span>，<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="comment">//过滤器业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="局部过滤器"><a href="#局部过滤器" class="headerlink" title="局部过滤器"></a>局部过滤器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    filter:&#123;</span><br><span class="line">        过滤器名称:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><blockquote><p>Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</p></blockquote><p>实例的生命周期-分为3个大阶段 </p><p>阶段一渲染： </p><p>阶段二数据改动，更新数据：</p><p>阶段三：销毁vue实例会触发， 该阶段中，我们主要记住mounted函数，以为页面数据已经渲染完成，我们之后会常用它调用ajax接口去渲染页面数据。</p><ul><li><strong>beforeCreate（创建前)</strong><br>在数据观测和初始化事件还未开始</li><li><strong>created（创建后）</strong><br>完成数据观测，属性和方法的运算，初始化事件，el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</li><li><strong>beforeMount(挂载前)</strong></li><li><strong>mount*********</strong>&lt;。)#)))≦-/<em>ed(挂载后)</em>*<br>DOM 渲染在 mounted 中就已经完成。</li><li><strong>beforeUpdate（更新前）</strong><br>在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li><li><strong>updated（更新后）</strong><br>在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li><strong>beforeDestroy（销毁前）</strong><br>在实例销毁之前调用。实例仍然完全可用。</li><li><strong>destroyed（销毁后）</strong><br>在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li></ul><p>同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p><img src="https://img2018.cnblogs.com/blog/1344042/201909/1344042-20190911140831736-1797567922.png" style="zoom: 50%;" /><h1 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h1><blockquote><p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p></blockquote><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h1 id="数据请求：Fetch-API"><a href="#数据请求：Fetch-API" class="headerlink" title="数据请求：Fetch API"></a>数据请求：Fetch API</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue (读音 /vjuː/，类似于 &lt;strong&gt;view&lt;/strong&gt;) 是一套用于构建用户界面的&lt;strong&gt;渐进式框架&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;vue响应式系</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>this的指向问题</title>
    <link href="https://chengling0824.github.io/2021/03/24/JavaScript%E4%B9%8Bthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
    <id>https://chengling0824.github.io/2021/03/24/JavaScript%E4%B9%8Bthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-24T04:08:02.000Z</published>
    <updated>2021-04-12T03:32:29.906Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h1><blockquote><p>this是一个对象，但是我们不同的操作 this指向的对象是不相同的。</p></blockquote><h2 id="三种-this指向情况："><a href="#三种-this指向情况：" class="headerlink" title="三种 this指向情况："></a>三种 this指向情况：</h2><ol><li><p>对象调用，this 指向该对象（前边谁调用 this 就指向谁）</p></li><li><p>直接调用的函数，this 指向的是全局 window 对象</p></li><li><p>通过 new 的方式，this 永远被绑定在新创建的对象上，任何方式都改变不了 this 的指向</p></li></ol><blockquote><p>new的过程，其实在内部创建了一个空对象，然后将构造函数传入的参数和属性挂在了这个空对象上，然后返回了这个对象。</p></blockquote><h2 id="扩展：箭头函数的-this-指向谁？"><a href="#扩展：箭头函数的-this-指向谁？" class="headerlink" title="扩展：箭头函数的 this 指向谁？"></a>扩展：箭头函数的 this 指向谁？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D;&#123;</span><br><span class="line">    a:()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行程序，控制台输出：</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/11/14/16e6758e10fbf72e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><blockquote><p>我们可以得出结论，this在箭头函数中失效了，因为这是由于箭头函数没有单独的 this值。</p><p>箭头函数的 this与声明所在的上下文相同。</p><p>也就是说调用箭头函数的时候，不会隐式的调用 this参数，而是从定义时的函数继承上下文。</p></blockquote><h1 id="如何改变-this-的值？"><a href="#如何改变-this-的值？" class="headerlink" title="如何改变 this 的值？"></a>如何改变 this 的值？</h1><ol><li><p>call 方法</p></li><li><p>apply 方法</p></li><li><p>bind 方法</p></li></ol>]]></content>
    
    
    <summary type="html">this是一个对象，但是我们不同的操作 this指向的对象是不相同的。 三种 this指向情况： 1. 对象调用，this 指向该对象（前边谁调用 this 就指向谁） 2. 直接调用的函数，this 指向的是全局 window 对象 3. 通过 new 的方式，this 永远被绑定在新创建的对象上，任何方式都改变不了 this 的指向...</summary>
    
    
    
    <category term="javascript" scheme="https://chengling0824.github.io/categories/javascript/"/>
    
    
    <category term="javascript" scheme="https://chengling0824.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>markdown常见指令</title>
    <link href="https://chengling0824.github.io/2021/03/24/markdown%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/"/>
    <id>https://chengling0824.github.io/2021/03/24/markdown%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/</id>
    <published>2021-03-24T04:08:02.000Z</published>
    <updated>2021-04-09T01:57:48.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><p>   · 标题通过 <code>#</code> 的个数来进行区分，Mardown总共支持6级标题。</p><span id="more"></span><h2 id="字体设置："><a href="#字体设置：" class="headerlink" title="字体设置："></a>字体设置：</h2><p>   · <strong>粗体：</strong><br>        字符串前后均加上 <code>**</code></p><p>   · <em>斜体</em><br>        字符串前后均加上 <code>*</code></p><p>   · <del>删除线</del><br>        字符串前后各加 <code>~~</code></p><p>   · 标记<br>        字体前后加上 ` (Esc下方的那个键)     </p><h2 id="区块引用："><a href="#区块引用：" class="headerlink" title="区块引用："></a>区块引用：</h2><blockquote><p>在使用的地方引用 <code>&gt;</code> (后面文本加空格)</p></blockquote><h2 id="首行缩进或空格"><a href="#首行缩进或空格" class="headerlink" title="首行缩进或空格"></a>首行缩进或空格</h2><p>   &nbsp; <code>&amp;nbsp;</code></p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>   · 连续多个（- 或 * 或 _）</p><hr><hr><h2 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h2><p>   图片<br>       <code>![]() : [图片名称] (图片网络地址)</code></p><p>   链接<br>       <code>[]() ： [链接名称(可自定义)] (链接地址)</code></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>   · 使用（<code>```  代码  ```</code>）</p><h2 id="网址自动转换"><a href="#网址自动转换" class="headerlink" title="网址自动转换"></a>网址自动转换</h2><p>   · 使用<code>&lt;&gt;</code>就会自动把它转成链接</p>]]></content>
    
    
    <summary type="html">标题： 标题通过 `#` 的个数来进行区分，Mardown总共支持6级标题。  字体设置：粗体：字符串前后均加上 `**`  斜体：字符串前后均加上 `*`   删除线：字符串前后各加 `~~`   标记：字体前后加上 ` (Esc下方的那个键)</summary>
    
    
    
    
    <category term="markdown" scheme="https://chengling0824.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>vue路由的实现与钩子函数</title>
    <link href="https://chengling0824.github.io/2021/03/24/vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0/"/>
    <id>https://chengling0824.github.io/2021/03/24/vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-03-24T04:08:02.000Z</published>
    <updated>2021-04-12T03:32:20.380Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Vue的路由实现：hash模式-和-history模式"><a href="#Vue的路由实现：hash模式-和-history模式" class="headerlink" title="Vue的路由实现：hash模式 和 history模式"></a>Vue的路由实现：hash模式 和 history模式</h1><p>通常 SPA 中前端路由有2种实现方式：</p><blockquote><p>window.history<br>location.hash</p></blockquote><p>下面就来介绍下这两种方式具体怎么实现的</p><h2 id="一-history"><a href="#一-history" class="headerlink" title="一. history"></a>一. history</h2><h3 id="1-history基本介绍"><a href="#1-history基本介绍" class="headerlink" title="1.history基本介绍"></a>1.history基本介绍</h3><blockquote><p> window.history 对象包含浏览器的历史，window.history 对象在编写时可不使用 window 这个前缀。history是实现SPA前端路由是一种主流方法，它有几个原始方法：</p><p>history.back() - 与在浏览器点击后退按钮相同<br>history.forward() - 与在浏览器中点击按钮向前相同<br>history.go(n) - 接受一个整数作为参数，移动到该整数指定的页面，比如go(1)相当于forward()，go(-1)相当于back()，go(0)相当于刷新当前页面<br>如果移动的位置超出了访问历史的边界，以上三个方法并不报错，而是静默失败</p></blockquote><p>history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。<br>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="http://www.xxx.com/items/id%E3%80%82">www.xxx.com/items/id。</a> 后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p><h3 id="2-history-pushState"><a href="#2-history-pushState" class="headerlink" title="2.history.pushState"></a>2.history.pushState</h3><p>pushState(stateObj, title, url) 方法向历史栈中写入数据，其第一个参数是要写入的数据对象（不大于640kB)，第二个参数是页面的 title, 第三个参数是 url (相对路径)。</p><p>stateObj ：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。</p><p>title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。</p><p>url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</p><p>关于pushState，有几个值得注意的地方：</p><p>pushState方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应,只有当触发前进后退等事件（back()和forward()等）时浏览器才会刷新</p><p>这里的 url 是受到同源策略限制的，防止恶意脚本模仿其他网站 url 用来欺骗用户，所以当违背同源策略时将会报错</p><h3 id="3-history-replaceState"><a href="#3-history-replaceState" class="headerlink" title="3.history.replaceState"></a>3.history.replaceState</h3><p>replaceState(stateObj, title, url) 和pushState的区别就在于它不是写入而是替换修改浏览历史中当前纪录，其余和 pushState一模一样</p><h3 id="4-popstate事件"><a href="#4-popstate事件" class="headerlink" title="4.popstate事件"></a>4.popstate事件</h3><p>定义：每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。</p><p>注意：仅仅调用pushState方法或replaceState方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用JavaScript调用back、forward、go方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p><p>用法：使用的时候，可以为popstate事件指定回调函数。这个回调函数的参数是一个event事件对象，它的state属性指向pushState和replaceState方法为当前URL所提供的状态对象（即这两个方法的第一个参数）。</p><h3 id="5-history实现spa前端路由代码"><a href="#5-history实现spa前端路由代码" class="headerlink" title="5.history实现spa前端路由代码"></a>5.history实现spa前端路由代码</h3><p><a class="api a">a.html</a><br><a class="api b">b.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册路由</span><br><span class="line">   document.querySelectorAll(&#39;.api&#39;).forEach(item &#x3D;&gt; &#123;</span><br><span class="line">     item.addEventListener(&#39;click&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">       e.preventDefault();</span><br><span class="line">       let link &#x3D; item.textContent;</span><br><span class="line">       if (!!(window.history &amp;&amp; history.pushState)) &#123;</span><br><span class="line">         &#x2F;&#x2F; 支持History API</span><br><span class="line">         window.history.pushState(&#123;name: &#39;api&#39;&#125;, link, link);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 不支持,可使用一些Polyfill库来实现</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, false)</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><pre><code>// 监听路由window.addEventListener(&#39;popstate&#39;, e =&gt; &#123;  console.log(&#123;    location: location.href,    state: e.state  &#125;)&#125;, false)</code></pre><p>复制代码<br>popstate监听函数里打印的e.state便是history.pushState()里传入的第一个参数，在这里即为{name: ‘api’}</p><h2 id="二-Hash"><a href="#二-Hash" class="headerlink" title="二. Hash"></a>二. Hash</h2><h3 id="1-Hash基本介绍"><a href="#1-Hash基本介绍" class="headerlink" title="1.Hash基本介绍"></a>1.Hash基本介绍</h3><blockquote><p>在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；<br>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。<br>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.xxx.com,因此对于后端来说,即使没有做到对路由的全覆盖,也不会返回/">www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回</a> 404 错误。</p></blockquote><p>window 对象中有一个事件是 onhashchange，以下几种情况都会触发这个事件：</p><p>直接更改浏览器地址，在最后面增加或改变#hash；<br>通过改变location.href或location.hash的值；<br>通过触发点击带锚点的链接；<br>浏览器前进后退可能导致hash的变化，前提是两个网页地址中的hash值不同。</p><h3 id="2-Hash实现spa前端路由代码"><a href="#2-Hash实现spa前端路由代码" class="headerlink" title="2.Hash实现spa前端路由代码"></a>2.Hash实现spa前端路由代码</h3><h1 id="vue路由的钩子函数"><a href="#vue路由的钩子函数" class="headerlink" title="vue路由的钩子函数"></a>vue路由的钩子函数</h1><p>首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。</p><ul><li>beforeEach主要有3个参数to，from，next：</li><li>to：route即将进入的目标路由对象，</li><li>from：route当前导航正要离开的路由</li><li>next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。</li></ul>]]></content>
    
    
    <summary type="html">通常 SPA 中前端路由有2种实现方式： window.history ，location.hash。下面就来介绍下这两种方式具体怎么实现的：一.history 1.history基本介绍 window.history 对象包含浏览器的历史，window.history 对象在编写时可不使用 window 这个前缀。history是实现SPA前端路由是一种主流方法，它有几个原始方法：</summary>
    
    
    
    <category term="vue" scheme="https://chengling0824.github.io/categories/vue/"/>
    
    
    <category term="vue" scheme="https://chengling0824.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://chengling0824.github.io/2021/03/24/hexo%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://chengling0824.github.io/2021/03/24/hexo%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2021-03-24T04:04:19.812Z</published>
    <updated>2021-04-01T06:39:58.051Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
